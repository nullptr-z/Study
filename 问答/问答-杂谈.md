# 技能优先级

语言 》项目经验 》操作系统 》网络

## 层级越高的东西，限制越多

合适的规则和限制能激发创作灵感，不至于让人无从下手

## 为什么学习操作系统原理很重要

操作系统对算力,IO 设备资源统一封装，并提供调配接口，和提供安全性和可用性

实际上我们学习使用的很多编程语言、开发框架，本质都是为了更好的利用资源。
这些工具都是为了，融汇这些资源专注一个领功能，或者隐藏一些缺陷
但这并不是说有了这些工具，我们就不需要学习操作系统；

有了操作系统的深入的理解，能更快、更好的学习使用这些工具，理解这些工具为什么而存在；甚至创造新工具

有了操作系统的知识，当我们遇到没有遇到过的问题，能大概率降低摸瞎的可能性：

- 学习前：遇到问题不知道怎么办，它为什么会这样的错误，搜到了解决方案也看不明白
- 学习后：快速的定位问题的原因，精准查找解决问题相关的工具或解决方案

## 带着问题学习：

- 为什么要用这个框架，他解决什么问题
- 在不同的平台，他是否具有同样的价值和意义

## 学习要有广度，工作要有深度

不要因知识面过窄，限制了想象力，一个问题有多种解决方式

## Rust 现在就很完美吗？

它为什么编译这么慢。
所有权机制很棒，但编译器实现它的方式足够效率吗 ？

## Cpp 是否能通过引入一个开关，关闭那些陈旧的特性？

如果这样做了，是不是可以叫做 Cpp2.0

新老版本写的项目是否又能高效的结合运行

## Rust 为什么优秀

1. 它融合了很多语言的优秀特性，都是一些语言中经过实践的优秀特性，例如 Rc
2. 在像 C/C++这类开放语言中的优秀编码规范，本来有些编写规范需要程序员去遵守，Rust 通过编译器，提醒或者说强制你这么去做;，例如 RAII
3. 在所有权和生命周期的规则下 RAII 模式是自然发生的

## 不建议写垃圾代码

**代码是给人读的，编译后的指令才是给机器读的**

有时候为了赶紧实现功能，写出一段麻花一样的代码，耦合、可维护性差、隐含 BUG，可能当前是完成功能了；
但这种代码一旦出问题，而且通常来说也很容易出问题，维护的代价可能是写这段代码的好几倍；
我们往往在之后的代码中都对这段代码抱有假设性

ps: 重构这段代码的时候，最好/尽可能不要改变它的性质，出参/入参，保证逻辑一致性；当然最好是避免写出这种代码

## 怎么调试代码

尽可能短小的函数，让每一个函数通过它的 unit test

## 为什么程序员经验很重

因为踩过更多的坑，犯过更多的错，有更多的实践

一个项目周期，30%时间在 coding，70%在 debug，有经验的程序能写出更少 bug 的程序，只有犯过过错的程序员才能更快的定位 bug；

## 白话讲操作系统

操作系统内核就是一个优秀的资源整合专家，复杂调配各种资源（各自硬件调配），决策事情的轻重缓急；

良好可操作性实际上用户层面的，方面非专业人士使用操作系统

一些另类的操作系统：

1. 我们人**认知**是一个操作系统，大脑是 CPU，负责协调我们四肢去做一些事情，我们每个人做同一件事情的方式，受限于我们的**认知**；
2. 一个应用软件**核心业务**也是操作系统，基于软件提供能力，方便我们更专注于某一项任务；
3. 一个公司**规章制度与愿景**也是操作系统，员工需要在公司给予的资源下，完成它们的工作，公司安排的任务（进程）

操作系通过更新来满足用户的需求，我们人呢需要通过不断地学习，来提升更新我们认知能力

## 任务调度器

`yield` 会主动的将 CPU 还给线程调度器，并告诉线程调度器说，你可以让一些其他的线程运行了。这里的出让其实也是一种线程切换，它会保存当前线程的状态，并在稍后恢复。

> ps: 这是一种设计思想，就是在把控制权交换，在很多地方都有运用，
> JS 中的 Generate/yield 就是，Generate 执行时函数内部每当遇到 yield 就会暂停执行，控制权从生成器函数交还给调用者，等下一次调用 next()的时候从暂停的位置继续执行
> 这与操作系统 yield 思想一致的，yield 把 CPU 控制权交还给调度器

## 进程、线程、协程

ps: 通常提到进程通信是指的同一个软件的父子进程，fork()出来的

- 进程：运行在不同的页，父子进程之间完全隔离的，IPC 通信比较慢：管道(pipe 函数)、消息队列(FIFO)、共享内存、信号量甚至 Socket
- 线程：运行在同一个进行下，只需要通过共享内存就可以通信，保存必要的 Context
- 协程：协程是一种轻量级的线程，其执行流程可以在不同的代码块之间切换；由程序员控制，主动放弃 CPU 控制权，yield 或 await；协程的使用旨在简化异步和并发编程
- 不同软件之间的进程：通常使用 Socket 、序列化协议文件通信，实际背后都是用到系统调用了

## 计算机网络架构

学习计算机网络有一个最重要的作用，就是它有一个非常优秀的架构设计，这对于现在大型的软件**设计思想**是很有帮助的,例如：

- 他的分层设计，在现代复杂软件中分层设计是必然的，松耦合
- 协议设计，帮我们更好的软件系统设计接口
- 重传机制，分布式架构最终结果一致性
- 拥塞控制，负载均衡策略
- DNS 系统，这是就是一个非常伟大的分布式应用

前 2 点在平时小项目开发中也是非常重要的，可以说是一个程序员必备能力

事实上学习优秀框架设置，是我们必备的能力，很多框架我们不一定能用得上，但是学习它们的框架设计并用到自己的项目中，这种能力是非常重要的
