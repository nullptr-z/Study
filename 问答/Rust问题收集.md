## 哪些数据在栈上哪些在堆上？

在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上

## 为什么避免大量的数据分配在栈上

一个进程至少有一个执行线程，每一个线程都有自己的栈内存。在 64 位的 linux 系统上，Rust 程序缺省栈是 2MB，如果它使用的栈内存超了，程序就会被内核终止，并返回一个 stackoverflow 错误。

简单来说就是为了避免 stackoverflow

## 堆栈的优缺点

##### 栈

效率高，只需要移动栈寄存器就能完成分配和释放；

缺点，空间有限不能放大容量数据

##### 堆

空间充足管够；灵活，用多少分配多少，而且有些动态的类型也必须在堆上，栈上的类型一定是编译时大小确定的

缺点,

1. 分配/释放效率较低，需要系统调用 malloc/free
2. 如果在多线程场景下，还会引发数据竞争、野指针、悬垂指针等问题
3.

## GC or Arc

他们在不同场景下效率不一样，效率很难说

Arc： 把控更精细；有大量额外代码，虽然不需要程序员关注，但是影响性能

Gc： 减轻了程序员负担；GC STW(stop wait)效率挺低的

GC 分配和释放内存的效率和吞吐量要比 ARC 高，但因为偶尔的高延迟，导致被感知的性能比较差，所以会给人一种 GC 不如 ARC 性能好的感觉。

## 类型系统

汇编层面没有类型的概念只有指令、内存地址、立即数

类型系统是一种上层工具。为了编译器在编译时对数据做静态检查，或者语言在运行时对数据做动态检查的时候，来保证某个操作处理的数据是开发者**期望的数据类型**。
还用于抽象出各种概念，例如 OOP

## 智能指针

在 Rust 中，凡是需要做资源回收的数据结构，且实现了 Deref/DerefMut/Drop，都是智能指针。
String， Box<T> 和 Vec<T>、 Rc<T> 和 Arc<T> 。 PathBuf、Cow<'a, B>、MutexGuard<T>、RwLockReadGuard<T> 和 RwLockWriteGuard 等也是智能指针。

## Cow<'a, B>

用于提供写时克隆（Clone-on-Write）的一个智能指针;

包裹一个只读借用，但如果调用者需要所有权或者需要修改内容，那么它会 clone 借用的数据。

让你可以在需要的时候再获得数据的所有权。Cow 结构是一种使用 enum 根据当前的状态进行分发的经典方案。甚至，可以用类似的方案取代 trait object 做动态分发
