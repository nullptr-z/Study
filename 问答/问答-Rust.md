## Rust 如何保证并发安全的？

1. 一个可变变量默认就是互斥的，这与并发是用的锁异曲同工之处，一个变量只能有一个可变的引用，或者多个比可变引用，二者不能同时存在，者直接解决数据竞争问题；为了在多线程中安全地共享数据，Rust 提供了 Mutex 和 RwLock 等类型，它们使用互斥锁和读写锁来管理对数据的访问
2. 堆变量与函数调用栈(入参)生命周期绑定，函数作用域结束就销毁；几乎避免了悬垂指针出现的可能，也就是说他的所有可能得引用和数据本身都被释放了
3. 所有权 move 语义，默认赋值、传参就移动变量所有权，有助于避免数据竞争；如果不想移动那应该使用 clone 或者 Rc/Arc

## 如何返回函数内部创建变量？

1. 如果变量是 Copy 的，直接返回
2. 对于栈上的变量默认 Rust 是 move 的，直接返回即可转移所有权
3. std::mem::take 夺走变量的所有权，内部变量就变成了 default 的值了
4. 在堆上创建数据，如果担心开销，使用 Rc/Arc

## 三大扛把子

Stream、Future、Iterate,都是通过迭代产生一个值

## \*让我学会了什么

下意思会思考这个变量应该被转移所有权吗? 是否这里使用完了就该丢弃/释放?
围绕着生命周期选择一个变量的类型,任何资源分配都是遵循 RAII 模式的

只在必要的时候进行拷贝 Clone

在设置一个函数形参的时候,便开始思考使用者和开发者会怎样处理这个参数; 开发者一定知道一个变量生命周期
