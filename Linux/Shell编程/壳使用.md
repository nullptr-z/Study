#表示注释这一行;第一行有特殊用途,#!/bin/bash 这里标识了使用使用什么 shell 来执行脚本
一行一个命令

要让 shell 执行这个脚本文件,就是添加环境变量或者使用相对/绝对路径执行

切换 shell:
echo $SHELL 查看当前 shell
chsh -s /bin/bash 切换到 bash

打印信息:
echo:
\ 反斜杠,转义字符
$ ${} 输出变量

使用环境变量:
可以在脚本中使用变量,只需要用美元符号$标识这是在引用一个变量;
在引号中使用$默认情况依然是当做变量处理,如果需要打印$符号前面加上反斜杠/即可

使用自定义变量:
等号和值之间不能有空格
拼接时不需要加号
脚本结束时才会释放变量
变量名=值
值还可以是命令的输出内容:
`命令` 这是一对反引号(~键);
$(命令)    具有相同作用
以当前日期作为参数值:
变量名=$(date +%y%m%d) 得到 2 位年月日格式的日期,注意命令后空格是必要的

重定向输出:
命令>文件名 将命令的结果保存到文本中,每次都会替换整个文本
使用 >> 以追加数据方式,添加到文本后面

重定向输入:
命令<文件名 将文本的内容作用于命令
也不可以不用文件,而使用输入的内容:
命令<<标记 输入内容后,再次输入标记表示结束

管道:
将一个命令的内容作用于另一个命令:
可以把命令的内容输出到一个文本,再吧文本输入到命令,这样虽然可行,但是很繁琐,管道结合了这 2 步操作
命令 1 | 命令 2 将命令 1 的输出立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区;
数据直接输出在屏幕上,当然可以配合输出重定向将两个命令结合的结果保存到文件,例如
file1 | sort > file2 把排序后的文件保存到新的文件
再或者
命令|more 如果命令产生很长的输出则可以通过这样的方式来查看结果

算术运算:
$[公式] 这种方式较为常用,但是不支持浮点运算
expr 问题很多,使用很麻烦,只是为了兼容 Bourne shell

退出脚本:
echo $? 此命令中保存着上一个已执行 shell 命令状态码:
0 命令成功结束
1 一般性未知错误,例如提供了无效的参数
2 不适合的 shell 命令
126 命令不可执行,没有相应权限
127 没找到命令
128 无效的退出参数
128+x 与 Linux 信号 x 相关的严重错误
130 通过 Ctrl+C 终止的命令
255 正常范围之外的退出状态码

可以在脚本结尾使用 exit num 指定一个退出状态码(0-255),超出这个范围会进行取模--感觉不如系统返回的有意义

ARG1 | ARG2 如果 ARG1 既不是 null 也不是零值,返回 ARG1 ;否则返回 ARG2
ARG1 & ARG2 如果没有参数是 null 或零值,返回 ARG1 ;否则返回 0
ARG1 < ARG2 如果 ARG1 小于 ARG2 ,返回 1 ;否则返回 0
ARG1 <= ARG2 如果 ARG1 小于或等于 ARG2 ,返回 1 ;否则返回 0
ARG1 = ARG2 如果 ARG1 等于 ARG2 ,返回 1 ;否则返回 0
ARG1 != ARG2 如果 ARG1 不等于 ARG2 ,返回 1 ;否则返回 0
ARG1 >= ARG2 如果 ARG1 大于或等于 ARG2 ,返回 1 ;否则返回 0
ARG1 > ARG2 如果 ARG1 大于 ARG2 ,返回 1 ;否则返回 0
ARG1 + ARG2 返回 ARG1 和 ARG2 的算术运算和
ARG1 - ARG2 返回 ARG1 和 ARG2 的算术运算差
ARG1 \* ARG2 返回 ARG1 和 ARG2 的算术乘积
ARG1 / ARG2 返回 ARG1 被 ARG2 除的算术商
ARG1 % ARG2 返回 ARG1 被 ARG2 除的算术余数
STRING : REGEXP 如果 REGEXP 匹配到了 STRING 中的某个模式,返回该模式匹配
match STRING REGEXP 如果 REGEXP 匹配到了 STRING 中的某个模式,返回该模式匹配
substr STRING POS LENGTH 返回起始位置为 POS (从 1 开始计数)、长度为 LENGTH 个字符的子字符串
index STRING CHARS 返回在 STRING 中找到 CHARS 字符串的位置;否则,返回 0
length STRING 返回字符串 STRING 的数值长度

- TOKEN 将 TOKEN 解释成字符串,即使是个关键字
  (EXPRESSION) 返回 EXPRESSION 的值
