## 获取命令行参数

shell 脚本文件 参数列表 运行一个脚本时,后面可以跟上 N 个参数,以空格分隔,如果参数自带空格,使用任意引号括起来即可;
使用参数从$0-$N,如果参数大于 9 个得使用${10}这样的形式,通常从$1 开始使用,因为$0 是该脚本文件的名称;

$0 存在一个问题 ,他会把运行这个命令的脚本临时也包含在其中,例如使用完整路径运行这个脚本,参数就会是整个完整路径名
basename $0 可以解决这个问题,去掉目录路径

给定参数数量少于脚本使用的个数会出现错误
if[ -n $n ] 测试某个参数是否存在

$#    这个参数等于传递给脚本参数的数量,且无视参数是否有效
无法这样使用它${$#},而是另一种奇怪的方式${!#},如果没有传递参数,他会打印出这个脚本名
可以把$#赋值给一个变量,然后$变量名 这样的方式在没有参数的情况就会打印 0

$*    把所有参数当成一个整体,所有参数合成一个字符串,空格分开
$@ 代表着所有参数组成的对象集合
如果只是普通打印这两个参数,没有任何区别,用 for 循环会把$@分割成 N 个参数

$? 上一个程序的终止状态

shift: 移动变量命令
变量$3 的值会移到$2 中，变量$2 的值会移到$1 中，而变量$1 的值则会被删除（变量$0 的值不会被改变）
默认情况移动 1 位,当然可以给他一个数字参数指定移动个数

====================================

# 流程控制&比较

case 流程控制:
有一丝怪异的语法,但是基本上就是 swich
case b in
a) ommands1;;
b) commands2;;
c) default-commands;;
esac

if 流程控制:
如果 testCommand 命令执行后其退出状态码为 0,就执行 then,fi 为结束标记
if test Command
then
commandList
...
elif test Command
then
commandList
...
else
commandList
...
fi
if 只能用于测试命令退出状态码

使用双括号(( )) [[]]]进行判断:
if (( bool )) 与其他语言类似的逻辑运算
if [[str==str || str==正则]] 字符串还可以使用正则表达式

test 转换为状态码进行判断:
test condition : 条件成立,则返回退出状态码 0;等同于其他语言 true

test 配合 if 使用:
if test condition
bash 写法:
if [ condition ] 空格是必要的的

数值比较(非浮点):
n1 -eq n2 等于
n1 -ne n2 不等于
n1 -ge n2 大于或等于
n1 -le n2 小于或等于 --Less
n1 -gt n2 大于
n1 -lt n2 小于

字符串比较:
依据是 asicc 码的顺序,大写字母在小写字母前面,所以大写字母小于小写字母// sort 命令不一样(本地化的语言排序设置)
使用< >2 个符号时, 要在前面加上\, 不然会被解释成重定向符号
str1 == str2 检查 str1 是否和 str2 相同
str1 != str2 检查 str1 是否和 str2 不同
str1 < str2 检查 str1 是否比 str2 小
str1 > str2 检查 str1 是否比 str2 大
-n str1 str1 的长度不为 0(存在且长度大于 0)返回状态码 0
-z str1 str1 的长度为 0 返回状态码 0;未定义的变量被当做长度为 0
直接测试字面量好像和-n 功能一样

空的和未初始化的变量会对 shell 脚本测试造成灾难性的影响。如果不是很确定一个变量的内容,最好在将其用于数值或字符串比较之前先通过 -n 或 -z 来测试一下变量是否含有值。
可以看出来数值比较用了文字符号,字符串比较用了数学符号,则是为了更好的区分是在做何种比较运算;

文件比较:
-s file 检查 file 是否存在并非空
-e file 检查 file 是否存在 --equals
-d file 检查 file 是否存在并是一个目录
-f file 检查 file 是否存在并是一个文件
-r file 检查 file 是否存在并可读
-w file 检查 file 是否存在并可写
-x file 检查 file 是否存在并可执行
-O file 检查 file 是否存在并属主是否为当前用户
-G file 检查 file 是否存在并且默认组是否为当前用户
file1 -nt file2 检查 file1 是否比 file2 新 --new
file1 -ot file2 检查 file1 是否比 file2 旧 --old
最好吧文件名参数使用""包起来,以免出现遇到带空格的名字时,会把单词当成 test 参数看待,出现错误
