# 概念
*通常用于对常规容器集合的二次封装,以更快的方式获取值所在的存放地址(下标)*
* 散列地址 HashCode由 key配合算法生成,**散列地址就在 key当中**
* 由`散列函数` `散列表`组成,它们应该是互相独立,不互相依赖的
* 查表 与 造表过程相同

## 散列函数
接受一个 key值,生产一个 HashCode,创建和获取时散列地址都有`散列函数`返回,不同的 key可能生成相同的 HashCode,称之为`冲突`; 即: k1≠k2，而f(k1)==f(k2)
冲突次数: 通过散列地址定位后,之后不断迭代判断 key是否相同的累积次数
冲突越少,查找速度越快,所以生成 HashCode时,通常需要 key需要配合特定算法(djb2, 对折法),减少冲突可能性

* lose lose 很简单,将 key的 ascii相加,利于学习和理解比较多
* djb2 最受社区推崇的散列函数之一
``` rs
  // djb2
  fn get_hash_code(&self, key: &str) -> usize {
        let mut code: usize = 5381;
        for k in key.as_bytes() {
            code = (code << 5) + *k as usize;
        }
        code % 1013
    }
```

## 散列表
`HashCode`作为寻址的起始点,在存放数据时需要解决 `HashCode`冲突问题,几种处理方式：分离链接、线性探查和双散列法。
* 分离链接: 将相同`HashCode`元素放在一个单链表中
* 线性探查: 就是基于`HashCode`位置递增的找到一个空闲位置存放; 这种方式应该需要一个精心设计`散列函数`,不然可能花过多时间在迭代探查空闲位置上
* 二次离散:

与常规的递推 贪心 回溯算法等不同, 散列算法是一种概念,通过组合`散列函数`从`散列表`查找出值就可以叫散列算法
