————调试帮助 p 215

建议：变量在头文件中声明，在源文件中定义；函数也应该在头文件声明，在源文件定义； ——头文件也应该被包含在源文件

f（形参） 形参列表可以空，有一个其隐式 void
函数原型的形参名字可有可无，如果能取一个让人明白其作用的名字也是有好处的；原型放在头文件中便于统一管理

值传递 (传值调用)：传递副本，不修改原值
引用传递：绑定原始参数的别名（地址）；对一些容器类型传递，又不需要修改其值的情况，常量引用是明智的，传递庞大的容器副本效率很低
指针传递：根据地址操作实际数据，如果不需要修改操作建议使用引用代替

形参注意事项：
用实参初始化形参会忽略顶层 const
不需要写操作的参数不要申明为引用类型
普通引用能接受的对象类型也比引用常量要少，例如 const 对象、字面值或者需要类型转换的对象——对于不需要写操作的形参都写成 const 类型百利无一害

默认实参：
只要是能转换成对应类型的表达式都能做默认参数：宏，外部变量，表达式，运行时改变外部变量也能达到改变默认参数的效果
一旦某个形参被赋了默认值，他后面的所有形参都必须定义默认参数。
调用时不能跳过靠任何一个有默认参数的值；

函数原型可以重复定义，且可以从右往左的顺序吧没有给默认参数的形参添加默认值，已经添加的无法修改

虽然通过多次声明给还没有默认实参的参数添加默认值是合法的，但不建议这样做

可变形参：
……：一般用于 C++访问 C 标准库 varargs 参数用的，用于 C++类型通常会出出错

initializer_list: 同名函数头
一种标准库类型，用于表示某种特定类型的值的数组，元素类型都相同
和 vector 一样是模板类型，但是他的元素永远是 const 类型

传递数组：
任何形式都是传递首指针 int\*类型（所以可以接受普通指针和数组传递），[n]也只是期望接受大小，没有实际意义，被调函数也并不能通过指针知道数组的长度;
标识尾数组的方法:
1.C 风格字尾用空字符标识，通常只适用于字符串操作 2.传递尾后元素指针.end() 3.显示传递长度（使用 size_t 类型）；

返回值：
void 返回类型可以不 return，他有一个隐式的 return，但是也可以返回另一个 void 函数
函数内部的局部变量，在函数结束时都会被释放掉，所以不要返回一个局部对象的引用或指针，他们的值是未定义的——或许传递给函数 指针和引用 在内部修改能打到相同的效果

main 也可以不给返回值，编译器添加隐式 return 0——大部分操作系统代表着正常退出程序
为了避免操作系统可能存在差异，标准库有两个预处理变量:
return EXIT_FAILURE // 程序运行异常退出
return EXIT_SUCCESS // 程序正常退出

如果一个函数返回引用类型(非常量)，则这个返回值就是一个左值，可以直接对返回值进行赋值

左值函数：
非常量的带返回值的函数，还可以作为左值使用

返回值：
传递值和返回值一样都使用引用而非副本效率更高

声明返回数组函数：
int (\*sum(int ))[5]; sum 接受一个 int 类型的参数，返回一个指针，这个指针指向包含 5 个元素的数组，数组是 int 类型的

尾置返回 c++11 auto sum(int )->int (*)[5]; 效果如上——二维数组
decltype(arr) *sum(int) decltype 返回 arr 是什么类型的数组，并不把他解释为指针，所以函数声明时需要手动加一个\*表示返回指针

内联函数：
inline 在返回类型前面加上就可以请求编译器在这个函数调用的位置使用直接展开代码的方式，而不是调用（开销增加）——只是请求，还有很多编译器不支持内联函数

constexpr 函数: ——p 214
在编写是就知道可以预知的函数可以手动加上这个修饰符，减少汇编代码量
这种函数的返回值和形参都得是字面值类型，而且函数只能有一条 return 语句;
这种函数编译器把他隐式的转为内联函数，执行初始化任务时，编译器把该函数的调用替换成结果值
函数形参是常量表达式时返回值也是常量表达式，反之亦然——返回值不一定返回常量表达式，取决于形参类型
内联函数和 constexpr 通常直接定义在头文件中
只能调用其它 constexpr 函数
只能使用全局 constexpr 变量

函数指针：
把函数声明替换成(\*p)即可，直接把函数名拿给指针， &可以不写，使用时也无需解引

函数重载：
main 无法重载
函数名相同 形参列表不同称为重载
形参列表顶层 const 没有区分作用，底层 const 有效
const int& const int\* 都属于底层 const
在一个局部作用域声明的函数并不会和外层的函数起到重载作用，会把外层的忽视；而且 并不建议在局部作用域声明函数
——其实通过推测编译器是否有办法区分我们需要调用哪个,如果没办法区分则没法办重载

函数匹配 p217

生命周期：
static 局部静态对象在第一次被运行执行后初始化，不会因为函数执行结束被销毁；——和外部变量一样启动时被创建（加载到 data 段）——所谓的初始化只是执行了第一次以后才能使用（加载）
