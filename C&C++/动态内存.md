allocator

## 使用动态内存的三种原因：

- 程序不知道自己需要使用多少对象
- 程序不知道所需对象的准确类型
- 程序需要在多个对象间共享数据

## new

=new type 默认初始化
=new type( )值初始化
尽量保证动态对象都进行了初始化
对于自定义类型任何初始化方式都没有意义，必将使用构造函数来初始化

( )括号初始化
使用了括号进行初始化的动态对象，可以使用 auto 来推断要分配的类型，注意括号只能有单个值

new 内存分配失败默认抛出 std::bad_alloc 异常
new（std::onthrow）传递此对象告诉 new 分配内存失败也不要抛出异常,并返回空指针

## delete

delete 要释放的指针必须指向动态分配的内存或空指针
释放非 new 分配的内存 行为是未定义的；释放指向相同动态内存的多个指针 可能破坏自由空间，释放一个空指针总是可行的
大多数编译器不知道一个指针指向的是静态还是动态内存，也不能分辨内存是否已经释放，对于这些 delete 表达式总是便通过，实际上是错误的

空悬指针是指曾经保存着数据对象但现在已经无效的内存指针，为初始化指针的弊端空悬指针都有。两种避免的方法：
一种是释放内存后将指针赋值为 nullptr，表明这个指针不再指向任何对象
一种是即将离开此指针作用域的时候释放他指向的对象
——但是依然无法使其他也指向这个对象的指针失效

const 对象虽然是不可修改的，但是同样可以被销毁，让 delete 指向 const 对象的指针即可

## 智能指针和异常

在 new 和 delete 之间的代码发生异常该 new 对象将无法被释放，但智能指针就没有这种弊端

管理者唯一的情况，用智能指针的 get()函数得到的一个内置指针来初始化一个临时的智能指针，一旦该内置指针被释放，指向的内存也会被释放，原来的智能指针就会变成悬空指针，销毁这个智能指针时会再次执行 delete 将发生错误

## C++内存布局

“在 C++中，内存区分为 5 个区，分别是堆、栈、全局/静态存储区、常量存储区、自由存储区(C++独有的概念)”。
序员可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。

- 自由存储是 C++中通过 new 与 delete 动态分配和释放对象的抽象概念，而堆（heap）是 C 语言和操作系统的术语，是操作系统维护的一块动态分配内存。
- new 所申请的内存区域在 C++中称为自由存储区。藉由堆实现的自由存储，可以说 new 所申请的内存区域在堆上。
- 堆与自由存储区还是有区别的，它们并非等价。

## 分配

new 分配一个数组返回的的首地址的指针，默认情况下 值都是未初始化的：string 有所例外
