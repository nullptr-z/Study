EOF 代表文件和流的结束标识,表示没有更多资料可读取

\1234 指 8 进制 123 和 4
\x1234 表示一个 16 进制数 ;转义字符就是通过这样方式实现

istream 标准输入类型
osteam 标准输出类型 ——他们的数据不能被拷贝，但可以引用

IO 类型不可拷贝，由于读写会改变流的内容，只能用引用传递

## 内置类型：

定义于任何函数体之外的变量都被初始化为 0,；定义于函数体之内的任何内置类型都不被初始化（未定义值），试图访问将引发错误
默认初始化
string 为空“” int 为未定义
值初始化
string 为空“” int 为 0

double b=3.14125
int a{b} 错误，强制转未得到执行，应为存在丢失新的的危险
int c(b) 正确

建议显示初始化每一个内置类型变量

## 机器相关的类型:

size_type 无符号 对于当前容器类型最大可能的大小
size_t 无符号
ptrdiff_t 有符号

char 因机器不同可能被当成有符号或无符号，所以最好指定确定类型 unsigned,signed

double 双精度和 float 单精度所需代价很相差无几，甚至某些机器双精度比单精度更快（可能是边界偶对齐的原因）
long double 通常用不上 而且消耗大

int 通常等于机器的位数

nullprt 属于指针字面量

## 复合类型：

基于其他类型定义的类型 比如指针 引用 数组

## 对象：

指一块能储存数据并具有某种类型的内存空间

初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代
定义于函数体的内置类型的对象如果没有初始化，则其值未定义的。类对象如果没有显示的初始化，则其值由类的构造函数确定

## 引用:

他只是一个已经存在的对象的另一个名字，初始化值必须是一个对象且类型相同，一旦定义引用就无法修改绑定——引用不是指针,也不能被指针指向，因为 引用不是对象，不存在地址——（类似指针）传递值得方式不是副本形式，而是地址，无法迭代
必须与要绑定对象严格对应,隐式转换规则无效

## 指针: ——不要试图对尾后指针解引，编译器也无法发现的错误

本身就是一个对象(自己有地址)，默认初始化值 nullptr(c++11 新标准)

指向同一对象的指针相减的距离为 ptrdiff_t 有符号类型：相加是没有意义的

\*const 常量指针，不可更改指向的地址

void*：
可以存放任意对象的类型，因为类型是不确定的，所以不能直接使用他所指的对象，但可以用于同别的指针作比较、传参和赋值给另一个 void*——(原理:可能只是存放一了一个地址值,没有定义以多长字节取值;没有类型；例如 int:取 4 字节)
任何指向非常量的指针类型都能转化为 viod\*

修饰符与声明
int * a,b；a 是指针，b 是变量（*靠向变量名有助于区分 int \*a,b）

int *&a &说明是一个引用，*说明他引用的对象是一个指针，int 说明引用的这个指针是 int 类型——（从右往左读）指针无法指向引用，因为引用不是对象

const
编译时就要确定值，被调用的位置直接用被字面值替换；主要作用限制在编写期间修改其值
默认情况下 const 对象设定为仅在当前文件内有效，如果其他文件出现了同名 const 对象，相当于其他文件也定义了；
可以在定义和声明处加上 extern，这样就只需要定义(赋值)一次,多个文件共享一个 const 变量

常量的引用/指针
指对一个常量的引用,如果一个对象是常量,这对他的引用必须是常量引用; 这样的引用只是对自己本身的限制,自觉地不在去改变引用的对象,与对象本身无关,所以被绑定的对象可以是常量,也可以是非常量

常量引用
指引用引用本身被 const 限定,这样的限定使其引用一[ 字面量, 一切可以被计算为与引用同类型的表达式] 都变得合法--
原因:
编译器将表达式先复制给一个临时量(temp,通常是一个限定为 const 与引用同类型的变量)暂存,再将其绑定到引用上,
一个普通的引用显然是不支持绑定一个字面量或表达式,因其可能是可变的

常量指针
指针本身不可修改指向的地址

顶层 const: 指针本身是常量,无法更改指向的地址——在复合声明的右边
底层 const: 与复合类型的基本类型是常量，指针指向的对象是底层 const，可以改变指针本身指向的地址
将右值类型赋给左值；通常会忽略顶层 const,保留底层 const（传递的是对象，而不是指向对象的对象(指针本身)）——原因:
不可变的(const)指针和可变指针,都可以传递他指向的对象
——在复合声明的最左边

对整数式使用&取地址会得到指针类型，对 const 使用&取地址，顶层 const 就会变为底层 const: 猜测原因
引用本身就是不可变的,他本身不是一个可以被 const 修饰,所以会把对象当成一个整体进行引用

指针比较特殊是顶层 const 的同时也可以是底层 const:
const int \*const: 指针本身不可改变指向的地址, 指向的对象可以是常量也可以是非常量

auto:（c++11）
对引用使用 auto，可以保留顶层 const，因为引用只是取别名

常量表达式 类型为 const,编译时就能计算出数值(字面值)的表达式，字面量本身就是常量，通常在 Release 模式下常量都会直接被编译成字面量，debug 模式直接入栈字面值（其他类型是在栈中的地址）

constexpr：
被修饰对象只能被赋予一个常量表达式
如果修饰指针和引用则必须赋予有用固定地址的对象，指针还可以是 nullptr 和 0

无论是 const 还是 constexpr 都只对被赋值对象进行修饰限定，与值本身没有关系

decltype:（c++11）
decltype（表达式）val(等于表达式的类型) 他不需要右值，除非是赋予了引用类型和 const（必须给初始值）——他得到类型是'表达式'结果的得到的类型
需注意的是'表达式'如果是指针解引操作，则会得到引用类型
如果'表达式'使用了 2 层( )就会被当成该表达式类型的引用，言而言之得到的永远是引用类型
&p 取地址操作则会得到\*\*p 类型

- auto 忽略顶层 const，decltype 保留顶层 const；
- 对引用操作，auto 推断出原有类型，decltype 推断出引用；
- 对解引用操作，auto 推断出原有类型，decltype 推断出引用；
- auto 推断时会实际执行，decltype 不会执行，只做分析。总之在使用中过程中和 const、引用和指针结合时需要特别小心

mutable:易变的，和 const 相反，任何位置都可以改变，仅限于作用域内的副本值修改，并不是修改原值本身——和引用的区别

别名：
typedef 类型重命名，例如 typedef int\* x 就可以使用 x 来声明 int 指针了
using 名字 = 类型 功能和 typedef 相仿
例子：函数指针

预处理器：
#define 设置一个预处理器变量
#ifdef 变量已定义，为真 ；
#ifndef 变量未定义，为真 ；#endif 结束 if
用这两条语句保护头文件是个好习惯

---

强制转换：
istream 和 string 可以隐式转换，字面值字符串无法直接转换为 istream

避免无符号类型和有符号类型一起做运算
例：将无符号值和 int 相加时自动把 int 转化为无符号；如果 int 是负数将会产生很大的值（正数模），因为负数最高二进制位为 1
——负数取模如 8 位可表示 256 个数 256-这个负数的补数

bool 任何非 0 他都为真（强转为 1）

强制类型转换————p 145{
每一次写了一条强制类型转换，都应该反复斟酌能否以一其他方式实现相同的目标，如果实在无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，减少错误发生的机会

dynamic_cast

static_cast 任何具有明确定义的类型转换，只要不使用 const，都可以用
——以上两种都不该太频繁使用

const_cast 只能改变运算的对象的底层 const——除了有重载函数的上下文中使用，其他情况使用它都说明程序存在某种设计缺陷

reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释——对类型在底层以何种类型访问的改变，对于高级语言来说很危险（可能会导致堆栈释放不完整，子程序返回地址之类的错误），适合对编译器实现转换过程比较了解的人使用

编译器将 static_cast，const_cast 对比合法性，如果合法就其一方式，否则执行 reinterpret_cast 方式

旧式转换：
(type) name C 风格
name (type) 函数风格
}
