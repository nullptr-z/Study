sw: send window
rw: recv window

# stop and wait
停止等待协议, rdt1.0 rd2.0 rd2.1 rd3，利用率太低，一次只能通过条数据
rd3: sw = 1, rw = 1；发送必须得到确认才能发送下一个分组

# pipeline
流水线协议，分为`Go Back N`和`Selective Repeat`

## sliding window
滑动窗口协议

## Go Back N
sw > 1, rw = 1；只能顺序接受
发送方可以发送多个报文段，多个发送缓冲区；
接收方只能一次接受一个报文段且做出确认，一个接受缓冲区
发送方只启动一个定时器，即下一个待确认的报文段
发送方发送了多个报文段，其中第 n 个没有得到确认，超时定时器到时会重传，从 n 开始重传发送缓冲区所有报文段

## Selective Repeat
sw > 1, rw > 1；可以乱序接受
发送方和接收方都收多个缓冲区
发送方对每一个发送的报文段启用一个超时定时器，当某其中报文段在，超时前没有收到则重传这一个报文段
多个定时器，消耗比较大

## 乱序到达
即接受到了多个报文段，其中一个报文段比它序号更靠后（大）的已经到达了，他还没有到达，比他序号更靠后的这些报文段就是乱序的

## TCP的可靠传输
实际上 TCP 使用` Go Back N` 和 `Selective Repeat`结合的解决方案
> 只启动一个定时器，记录发送缓存区中第一个还未确认的报文段
> 快速重传一个大概率（99.6%）丢失的报文段
> 接收方只关心 ACK 确认号是多少，发送对应的分组
> 实际上对于乱序到达的分组，可丢可存；如果接收方不缓存，让发送方重传所有失序的分组；TCP协议中没有明确规定的


## 超时重传
在发送一个报文段时，本地会启动一个超时定时器，如果在定时器到达之前没有收到确认 ACK,会重新发送这个报文段

## 快速重传
2. 接收发送一个 ACK，希望下一次收到这个报文段
3. 在接下来收到报文段，收到的 Seq 比希望收到的Seq 大
4. 此时出现乱序，接收方任然传递希望收到的 ACK，第 1 次是为正常确认ACK， 之后 3 次 ACK 被称作冗余 ACK ——重传算法绝决定的这个次数
5. 发送方接收到了 3 次冗余 ACK，会立刻重传这个报文段，这就是快速重传

## 累计确认
收到一个报文段后，暂时隐忍不发送确认，等待一个500ms的辅助定时器，等待下一个的报文段到来，一起给确认，等待期间如果定时器到时，则直接发送确认

## 第三次握手
其作用其实就是获取，对方的接受缓存区是否可用情况; ...网络是否通畅，端到端之间链路是否正常

简而言之，双方控制变量做置位，准备好缓存区大小receive buffer，双方确认

这三段报文被称作**三次握手**

1. 客户端发送一个特殊报文段；SYC置位、Seq、，接受缓存区大小receive buffer
2. 服务端用一个特殊报文段来响应；SYC置位、Seq、ACK、接受缓存区大小receive buffer
3. 客户端再用一特殊报文段作为响应；ACK、确认收到服务端的缓存区信息


其中 1，2 不承载‘有效载荷’，3 可以承载；
3的时候时间可以开始传送数据了，只需要`捎带`确认 ACK 就可以了

Seq的设置不应该是固定的，可能会出现上一次链接，相同端口号网络滞留的数据，seq恰好在一个报文段；Seq跟时钟挂钩可以让这种情况缩小到极微（网络并不完美）

> 客户进程与服务进程完成三次握手，客户进程通过套接字传送数据流，之后数据流被客户端 TCP 接管，直到服务端 TCP 将数据流交给他的应用层

### 两次握手

> 如果只有两次握手，则可能出现超时重传等因素
出现半链接，为这个链接准备好的缓存区资源就会被浪费：
客服链接请求得到了服务的同意，在收到链接同意确认前，超时重传机制又发送了链接请求，此时之间的那个链接就是一个半链接
三次握手如果出现这种情况，他可以通过服务器的同意链接确认知道，这是一条重复请求，从而求情关闭这条链接

> 还可能出现两军问题，悖论；不知道对方是否收到确认，发送确认的确认。。

## 第四次挥手
