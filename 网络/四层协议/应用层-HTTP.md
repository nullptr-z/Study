_应用层协议常常被开发者，误以为是网络应用程序的一部分，实际它应该属于网络协议部分_

1. 如何构造报文？
2. 报文中各个字段的含义？
3. 何时发送报文？

## HTTP 协议--超文本传输协议

当今 web 的核心,它分为客户端和服务端，通过交换 http 报文进行会话

- 使用 TCP 协议作为运输载体,使用套接字接口与之 TCP 收发报文，一旦向套接字接口发送一个请求报文（与 TCP 链接），这个报文就脱离控制，完全由 TCP 接管
- HTTP 是*无状态协议*，每次请求都是独立存在，服务器不会保存来自同一客户的信息；通过 Cookie、session 能保持状态
- HTTP 与 TCP 默认使用`持续性链接`（即，所有请求/响应使用相同的 TCP 链接），但是也能配置成`非持续链接`

- 非持续性链接：

  > 如果在网页访问中服务器要返回 N 个资源（文件、图片），那么每个资源都会经历 TCP 链接/断开, 至少 N\*2 个 RTT，经历三次握手

- 持续性链接：

  > 一个完整的 web 页面，使用单个持续 TCP 链接进行传送
  > 可以连续发出请求（流水线，串行）

## HTTP1.1 半双工

客户端没有发起请求时，服务端不能主动推数据；

- 长连接 Keep-Alive，允许了在一个 TPC 链接上，发送多个请求，但是请求的顺序和响应的顺序*串行*的，一一对应的，不会乱序，这是一种**应用层头队阻塞**的通讯；算是一种不完整的多路复用
- ps: 1.1 之前每个资源都要经历一次握手

## HTTP2:

> 同一域名下的链接使用一个 TCP 链接；一台服务器上的多个 web 页面，发送给同一个客户时也可以在一个持续 TCP 链接上进行
> 多路复用： HTTP2 请求和回答还可以是交错的（并行），在服务器上对同一个域名下的的访问，多个 HTTP 连接共享一个 TCP 连接，TCP 是持续的
> Header 头部压缩，部首在持续连接中一直被缓存，只需要追加或者替换部首，减少了数据冗余传输；HPACK 算法
> server push,服务器主动推送客户端会用到的文件，但是客户端可选择是否接受

## HTTP3

基于 Quick 协议，基于 UDP

- 解决头了端阻塞问题, QUIC 解决的

## Web 缓存器/代理服务器

- GET：在 get 请求报文中添加`If-Modified-Since`首部行

- 更新缓存
  > 浏服务发起请求，并把`If-Modified-Since`更新为，上一次服务器响应的`Last-Modified`的时间。服务器检查时间
  > 如果没有发生更改，并且状态码为‘304’: 表明没有发生更改，让客户端是有本地版本
  > 如果在这候之后网页已经发生修改，则在响应报文中返回对象；

CDN，位于客户和服务器之间，既是客户也是服务
如果有缓存返回客户网页副本；如果没有则向服务器请求，并转发给客户端

> 减少服务对客户的响应时间
> 减少服务器成本，例如算力、带宽
> ISP 中的缓存器还能减少，直接对 Intent 层的访问

## 应用层的数据与控制

数据与控制混合在一起的时候，大容量数据传输会导致阻塞后续的简短指令传输

> 控制链接：建立一个长连接，用于交互式命令，
> 数据连接：当遇到大容量数据传输的时候，创建一个新的临时链接，专门用于传输这组大量数据

## CGI

公共网关接口（Common Gateway Interface，CGI）是 Web 服务器运行时外部程序的规范，按 CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互，还可通过数据 API 与数据库服务器等外部数据源进行通信，从数据库服务器中获取数据。格式化为 HTML 文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有服务器都支持 CGI，可用任何语言编写 CGI，包括流行的 C、C ++、Java、VB 和 Delphi 等。

## 协议的基本格式

```sh
# 请求方式GET/POST API(uri) HTTP/版本 结束符号
# Method Request-URI HTTP/Version CRLF
GET / HTTP/1.1
Host: 127.0.0.1:8899

# uri: 是 HTTP 中的术语,URL 去除 `IP:port`(host)的部分, 每个`/`一个节点
# 非管理员用户只能监听大于 1024 的端口

### 响应

# HTTP 版本 状态码 短语 CRLF
# 一个使用 HTTP 1.1 版本的响应例子，其状态码为 200，短语为 OK

HTTP/1.1 200 OK
# 此处为header
# 此处为body
```
