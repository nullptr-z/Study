
## 进程凭证
每个进程都有进程凭证,它由这些ID组成:
  * 实际用户ID、实际组ID
  * 有效用户ID、有效组ID
  * 保存用户ID、保存组ID
  * 辅助组ID(附加组的ID)
  * 文件系统用户ID、文件系统组ID(Linux特有,是历史原因所遗留,现在的程序不要使用)

### 实际ID
登录时 shell从/etc/passwd文件中读取,第三个(用户ID)和第四个字段(组ID),作为进程的实际ID凭证
创建新进程时,字进程会继承这些ID


### 有效ID
通常有效ID和实际ID是相等的;某些系统调用会使其改变,运行set-user-ID、set-group-ID程序也会对其改变
  * 内核会根据有效ID来决定一个进程是否能向另一个进程发送信号
  * 当进行某些系统调用,访问某些系统资源时,将结合有效ID、辅助ID来决定授予该进程的访问权限

#### Set-(U/G)ID程序
*ps:*  
*set-user-ID、set-group-ID简称:set-id*
*--注意set-id权限位对shell脚本无效*

```sh
chmod u+s progName
chmod g+s progName
```

  * 设置了 set-id权限位的程序,通常来用标识可执行文件权限位  x会被设置为 s标识
  * 该程序会将进程的有效ID设置为可执行文件的ID(属主);
  * 以属主的权限运行,使进程获取常规情况下所不具有的权限
  * 一个属主为 root的程序设置 set-user-ID权限位,进程运行时会取得超级用户权限,将可以访问特权级系统资源
  * 当程序中使用了特权级系统调用,必须将其设置为 set-id程序,才可以给 root以外的用户使用

##### Linux系统中常用的 set-user-ID程序:
 1) password
 2) mount
 3) su

##### Linux系统中常用的 set-group-ID程序:
 1) wall:用于向tty组管辖的所有终端写入一条消息


### 保存ID
此ID是被用来和set-id结合使用的,设计意图在于增加编程时安全
  * 当一个 set-id程序开始运行时,保存ID就会被设置为有效ID相同;用于之后,将有效ID在 实际ID和保存ID之间切换
  * set-id程序运行期间,仅在需要有效(属主)ID权限进行操作时才进行切换,操作完成后将切换回实际ID

### 辅助ID
进程的附加组ID标识,登录时从组文件获取,创建新进程时会继承这些ID
在访问特定权限资源时和有效ID相结合决定其访问权限


---

## 获取和修改实际/有效ID
#### 获取:
这些调用总是会成功的
```c
  #include <unistd.h>

  uid_t getuid(void);   //获取实际用户ID
  uid_t gegid(void);    //获取实际组ID
  uid_t geteuid(void);  //获取有效用户ID
  uid_t getegid(void);  //获取有效组ID
```

#### 修改:
以给定的uid参数值来修改调用进程的有效用户ID、实际ID、保存ID

***方法一:***
```c
  #include <unistd.h>

  int setuid(uid_t uid);
  int setgid(gid_t uid);
```
非特权级:
  * 非特权级进程当调用 setuid时,仅能将有效用户ID修改为实际ID或保存ID
  * 非特权用户仅在执行 set-user-ID程序时,setuid调用才有意义,因为执行普通程序三个ID都是相同的
  * 可移植性问题:派生自BSD的系统,还会修改实际、有效和保存ID(改为实际或有效ID)

特权级:
  * 当特权进程调用 setuid传递非0值时,三个ID都将被置为传递的这个值;需要注意,一旦特权进程修改了其ID,他将丢失他所有的特权,也无法再使用 setuid将有效ID改回0
  * 在使用 setgid时,可以对组ID进任意修改,对组的ID修改并不会引起进程特权的丢失(是否拥有特权是由用户ID决定的)

***方法二:***

```c
  #include <unistd.h>

  int seteuid(uid_t euid)
  int setegid(gid_t egid)
```
非特权级:
  * 除了可移植性问题,和 setuid、setgid等效,仅能将有效用户ID修改为实际ID或保存ID

特权级:
  * 能够将有效ID修改为任意值,如果将有效用户ID改为非0值,则失去特权,但是可以通过实际ID或保存ID来恢复特权


---

## 独立修改实际/有效ID
```c
  #include <unistd.h>

  int setreuid(uid_t ruid, uid_t euid)
  int setrguid(gid_t rgid, gid_t egid)
```
  * 第一个参数:新的实际ID
  * 第儿个参数:新的有效ID
  * 如果只需要修改其中一个,传递给另一个参数-1即可

非特权级:
  * 只能将实际ID修改为有效ID,或实际ID(无变化)
  * 只能将有效ID修改为实际ID、保存ID,或有效ID(无变化)

特权级:
  * 能将实际ID和有效ID设置为任意值

同一下任意操作还会将保存ID设置为有效ID:
  1) 传递给 ruid值不为-1
  2) 传递给 euid值不等于当前实际ID
`setreid(getuid,getuid())`这个调用会永久放弃特权,无法恢复;因为保存ID也被修改为了当前ID

## 获取和修改辅助组ID
获取当前进程辅助组ID的集合,SUSv3规范还允许包含有效组ID,保存在给定数组中
```c
  #include <unstid.h>

  int getgroups(int gidsetsize, gid_t grouplist[]);
```
  * gidsetsize: 给定数组的长度,如果组ID数量大于这个值返回错误号EINVAL,为避免错误发生可将长度设置为 NGROUPS_MAX + 1(<limits.h>头文件)
  * grouplist: 给定数组的地址
  * 返回值: 置于 grouplist组ID的数量 --技巧:getgroups(0,grouplist),不经修改grouplist,就可以获得数组的数量

#### 获取 NGROUPS_MAX值
  * sysconf(_SC_NGROUPS_MAX)
  * Linux特有文件读取/proc/sys/kernel/ngroups_max


### 特权级进程修改辅助组
未纳入SUSv3标准,但所有Unix都有实现支持
```c
  #include <grp.h>

  int setgroups(size_t gidsetsize, const gid_t *grouplist)
  int initgroups(const char *user, gid_t group)
```
setgroups用`grouplist`指定的集合替换进程的辅助组ID

initgroups:
  * user: 登录用户的账号
  * group: 用于追加到辅助组的ID集合


<details>
<summary>凭证修改函数对进程用户ID的影响(图)</summary>

![avatar](./img_进程凭证.png)
</details>



