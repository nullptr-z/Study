## write/read 函数

没有偏移量参数

inode 必须维护一个隐士的偏移量

## inodes 编号

在 xv6， inodes 数据结构放在`块32`上；

- inode 0 在 块 32 的 0 偏移位置上
- inode 17 在块 33 的 0 偏移上

一个块 1024 字节，也就是说一个块编号: inode N 等于 64 字节

最后的`bn link`连接到一个大小 256 的块，所以 xv6 支持的总共`(256 + 12) * 1024` 的磁盘大小

```c
// 这是inode 1,根inode
struct inode{
  type  // 空闲、文件、目录
  nlink
  ...
  bn 1
  bn 2
  ...
  bn 11
  bn link
}
```

## 位图块

在`inode 45`，用于标记一个 bit 标识一个块是否在使用

## read/write 实现简述

通过文件描述符 fd 在他对应 inode 中保存了所在磁盘位置的 inode n、块、扇区、偏移信息，简单的计算就可以知道该去哪个位置读写了

## 扇区/块

虽然经常有人混用他们的称呼，实际上是不同的

- 扇区: 512 字节
- 块: 不同操作系统定义是不同的，通常是扇区的 N 倍

## SSD/HDD

SSD：速度通常是数百微妙到毫秒级访问时间

HDD：速度通常是数十毫秒级访问时间

## PCI/PCIe

任何 IO 设备都有`块编号: inode N`,协议通过这个编号来读写内容

不同的磁盘或者说不同外设，通过 PCI 协议来达成 IO 访问一致性，可以想到驱动程序就是在对不同块读写数据；当然这是目前主流的协议，还有 USB 等

## 驱动程序

一些复杂的设备，驱动程序还提供了很多特定功能；

磁盘，可以读写完成后通知完成了数据加载，这使得上层软件可以使用异步读写

## LRU

是一种缓存淘汰策略。这种策略的核心思想是保留最近被访问过的元素，而淘汰掉最久未被访问的元素。LRU 算法基于时间局部性原理，即最近使用的数据可能在近期内仍然会被使用。

LRU 算法的应用场景包括数据库管理系统、文件系统、Web 服务器等需要高效管理缓存的领域。
