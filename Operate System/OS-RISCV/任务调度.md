## 一个 CPU 核心

用户线程、内核线程、调度器线程、称呼是指，在同一个 CPU 核心上的三种不同的任务，并非真正意义的线程，一个 CPU 同一时刻只可能执行其中一个任务；
-- 不过话说回来，所谓的线程也就是被一个 context switching 分割成的不同的代码段，正好这三种任务都需要执行 CS

在内核中，有一个 cpu 结构体的数组，其中每个 cpu 结构体对应一个 CPU 核，每个结构体中都有一个 context 字段，proc 字段。

内核线程、调度器线程，在系统启动时配置好了栈空间

## 内核线程

每个 CPU 核心都有各自的内核线程，和各自的 context 对象, 保存在 `proc.h, struct proc` 结构体中。

## 调度器线程

每个 CPU 核心都有各自的调度器线程，和各自的 context 对象, 保存在 `proc.h, struct cpu` 结构体中。

功能：一个运行在 CPU1 上的进程，当它决定出让 CPU，它都会切换到 CPU1 的调度器线程，并由调度器线程切换到另一个进程。

<!-- ## context 保存在哪？

每个内核线程都有一个 context 对象。每个用户进程有一个对应的内核线程，它的 context 对象保存在用户进程对应的 proc 结构体中。

每一个调度器线程，它也有自己的 context 对象，但是它却没有对应的进程和 proc 结构体，所以调度器线程的 context 对象保存在 cpu 结构体中。在内核中，有一个 cpu 结构体的数组，每个 cpu 结构体对应一个 CPU 核，每个结构体中都有一个 context 字段。 -->

## 进程切换

1. 从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存用户进程的状态并运行第一个用户进程的内核线程。
2. 再从第一个用户进程的内核线程切换到第二个用户进程的内核线程。
3. 之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器。
4. 最后返回到第二个用户进程继续执行。

## 上下文 Context

context 对象总是由 swtch 函数产生，所以 context 总是保存了内核线程在执行 swtch 函数时的状态。当我们在恢复一个内核线程时，对于刚恢复的线程所做的第一件事情就是从之前的 swtch 函数继续执行，那里应该是一条返回内核的指令

## 上下文切换 CS

当人们在说 context switching，分好几种不同场景：

1. 一个线程切换到另一个线程，因为在切换的过程中需要先保存前一个线程的寄存器，然后再恢复之前保存的后一个线程的寄存器，这些寄存器都是保存在 context 对象中。
2. 在有些时候，也指从一个用户进程切换到另一个用户进程的完整过程。
3. 偶尔也会看到 context switching 是指从用户空间和内核空间之间的切换。
