## 调度器核心工作步骤

`scheduler()`函数

当发生 pre-emptive scheduling：

1. 保存当前运行环境保存到 Content 到内存某个位置(struct cpu)
2. 将 RUNNING 线程状态转换成 RUNABLE
3. 找到并恢复一个 RUNABLE 线程 Content

有几点需要注意:

1. 调度器切换线程这段工作流(1,2,3)需要具有原子性，是不被中断的，也不想被其他 CPU 看到，如果状态修改到一个中间结果状，接下电脑肯定会议一种诡异的方式运行甚至崩溃
2. 因此需要上锁，关闭中断，这样切换线程的整个流程就是安全的
3. 从一个哲学性角度来看，如果线程好不容易得到了 CPU 时间，如果应用层代码都还没得以执行就又被打断，那这个切换是毫无意义的

## 调度器中的几种线程状态

- RUNNING, 线程当前正在某个 CPU 上运行
- RUNABLE, 等待执行的线程；线程还没有在某个 CPU 上运行，但是一旦有空闲的 CPU 就可以运行
- SLEEPING，挂起的线程；还不想运行的线程，因为这些线程可能在等待一些 I/O 异步事件

## PCB

PCB, Process Control Block, 进程进行调度管理控制。存储了进程的状态、寄存器值、程序计数器、内存分配情况、文件描述符表等关键信息

`struct proc`的`state`维护了进程运行状态

`yield` 会主动的将 CPU 还给线程调度器，并告诉线程调度器说，你可以让一些其他的线程运行了。这里的出让其实也是一种线程切换，它会保存当前线程的状态，并在稍后恢复。

> ps: 这是一种设计思想，就是在把控制权交换，在很多地方都有运用，
> JS 中的 Generate/yield 就是，Generate 执行时函数内部每当遇到 yield 就会暂停执行，控制权从生成器函数交还给调用者，等下一次调用 next()的时候从暂停的位置继续执行
> 这与操作系统 yield 思想一致的，yield 把 CPU 控制权交还给调度器

## 抢占式任务调度

pre-emptive scheduling

通常指操作系统通过定时器中断，实现的任务调度

定时器中断将 CPU 控制权给到, 即使用户代码本身没有出让 CPU，定时器中断仍然会将 CPU 的控制权拿走，并出让给线程调度器。

## 非抢占式

voluntary scheduling

工作线程通过 CPU 指令主动放弃 CPU 控制权，让其他任务执行

这里和协程很像，实际上协程就是一种非抢占式的任务，不过在应用层实现的，更轻量级
