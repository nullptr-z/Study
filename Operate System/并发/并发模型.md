互斥的原理就是将，并行的流转换成串行流

## Product Consumer-生产者消费者

实际上就是在互斥锁的基础上，增加了唤醒条件，**找到确认唤醒条件**是核心

生产者生产资源(count++), 消费者使用资源(count--)：
这是理想情况，复杂情况条件要麻烦得多，产生的资源要满足一定量，还要考虑生产资源的类型，这使得唤醒条件变得复杂

`pthread_mutex_lock`: 上锁
`pthread_mutex_unlock`: 释放锁
`pthread_cond_signal`: 用于唤醒一个睡眠(等待在条件变量上)的线程。具体唤醒哪一个取决于系统的实现。
`pthread_cond_broadcast`: 唤醒所有线程
`pthread_cond_wait`: 用于将当前线程置于睡眠等待队列上；等待线程被唤醒，它们会重新尝试获取互斥锁。一旦获得互斥锁，线程就可以继续执行。

## Select

FD_ZERO // 创建空的描述符集合,后续循环监听这个集合中的描述符是否可读,进行相关操作
FD_CLR // 清除描述符集合
FD_SET // 描述符集合中添加一个描述符
FD_ISSET // 检测哪个描述符可以读了

- 如果 select 是靠轮询判断是否有资源可用的，那就是 非阻塞的
- 如果 select 发现没有可用资源，直接线程挂起了(wait 相关函数)，等待系统唤醒，那就是 阻塞的

## Peterson 算法

无锁算法，基于共享内存，这里是指不依靠硬件指令(原子指令)

_它通常不用于现实世界的场景。现代编程语言和操作系统通常提供了用于管理并发的内置机制，如锁和信号量，原子指令_

Peterson 算法通常用于教育目的，以说明互斥的基本原理。

该算法通常用于两个进程的情况。以下是 Peterson 算法的基本工作原理：

初始化：

两个共享变量：int turn; 和 int flag[2];
turn 表示进入关键段的轮到哪个进程（0 或 1）。
flag[2] 是一个数组，每个进程有一个标志，初始化为 false。
进入关键段：

进入关键段之前，进程将其标志设置为 true（flag[i] = true;）。
然后将 turn 设置为另一个进程（turn = 1 - i;）。
进程检查另一个进程是否在其关键段中，以及是否轮到另一个进程。如果两个条件都成立，它会等待。
退出关键段：

离开关键段之前，进程将其标志设置为 false（flag[i] = false;）。
关键思想是，一个进程只有在轮到它并且另一个进程没有试图进入关键段时才能进入关键段。如果存在冲突，不允许进入关键段的进程将等待。

需要注意的是，尽管 Peterson 算法清晰地说明了互斥的概念，但由于其局限性以及更高效的替代方案，如基于硬件的解决方案或高级软件算法，
