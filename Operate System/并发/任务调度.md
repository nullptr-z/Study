## 调度器核心工作步骤

调度器将非 RUNNING 线程的上下文保存在内存的某个位置

1. 产生 pre-emptive scheduling, 保存当前运行的上下文环境到内存某个位置
2. 将 RUNNING 线程状态转换成 RUNABLE
3. 恢复一个 RUNABLE 线程上下文环境，它保存在内存里

## 调度器中的几种线程状态

- RUNNING, 线程当前正在某个 CPU 上运行
- RUNABLE, 等待执行的线程；线程还没有在某个 CPU 上运行，但是一旦有空闲的 CPU 就可以运行
- SLEEPING，挂起的线程；还不想运行的线程，因为这些线程可能在等待一些 I/O 异步事件

## 线程调度器

`yield` 会主动的将 CPU 还给线程调度器，并告诉线程调度器说，你可以让一些其他的线程运行了。这里的出让其实也是一种线程切换，它会保存当前线程的状态，并在稍后恢复。

> ps: 这是一种设计思想，就是在把控制权交换，在很多地方都有运用，
> JS 中的 Generate/yield 就是，Generate 执行时函数内部每当遇到 yield 就会暂停执行，控制权从生成器函数交还给调用者，等下一次调用 next()的时候从暂停的位置继续执行
> 这与操作系统 yield 思想一致的，yield 把 CPU 控制权交还给调度器

## 抢占式任务调度

pre-emptive scheduling

定时器中断将 CPU 控制权给到, 即使用户代码本身没有出让 CPU，定时器中断仍然会将 CPU 的控制权拿走，并出让给线程调度器。

## 放弃调度

voluntary scheduling
