## 什么是并发

一段程序代码的副本各自独立运行，通常来说他们运行的时间也是不同步的

## 为什么需要并发

- 访问慢速 IO，等待过程中 CPU 可以继续为其他任务服务
- 推迟一些优先级低的工作，快速响应紧急任务
- 为多个网络客户端提供服务，每个任务都被分配到一个独立工作流去执行
- 利用多核 CPU 没有并发能力，就无法利用并行
- 同时执行多个任务的能力更符合人们的需求

## 同步机制

- 锁：互斥锁、自旋锁
- 读写锁（Read-Write Lock）： 读写锁允许多个线程同时读取共享数据，但只允许一个线程写入共享数据
- 条件变量（Condition Variable）, 基于锁，满足设定条件通知唤醒其他线程
- 信号量（PV）
- 屏障（Barrier）
- 原子操作（Atomic）
- 消息传递，线程间通信

同步机制则是在并发模型中用于确保正确协同工作的手段。

确保在生产者和消费者之间正确地进行数据交换和协同工作。这些同步机制帮助防止竞争条件和确保正确的执行顺序。

## 临界区

Critical Section，在并发程序的执行环境中，一段代码片段会访问公共资源(变量、设备、内存、文件..)，这一段代码就是**临界区**；
显然并发环境下需要加以限制，不然肯定会出问题

加锁后这段代码在多核下也是串行的, 也可以理解成这整段代码具有了原子性，因为对于其他线程来说，这段代码一旦进入肯定会从都执行到结束，即便被 CPU 打断，下次回来时 Content 甚至共享内存都不会发生变化

## 颗粒度

指的是临界区代码段的长度，颗粒度过大会影响性能，通常建议把不必要的代码放在锁外面，将大的临界区拆分成多个小的临界区(多锁)

## 进程状态

操作系统可以通过维护进程控制块（Process Control Block，PCB）等数据结构，记录和管理每个进程的状态信息，以及与其相关的事件。这样，它可以及时了解一个进程是否被阻塞，并在必要时采取相应的调度和处理措施。

运行态（Running）： 进程目前正在执行指令。
就绪态（Ready）： 进程已经准备好执行，但尚未分配到 CPU 时间。
阻塞态（Blocked）： 进程因为等待某个事件（如 I/O 操作完成）而暂时无法执行。
创建态（New）： 进程正在被创建。
终止态（Terminated）： 进程已经执行完成或被终止。
