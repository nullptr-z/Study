## 为什么使用锁

希望利用多核 CPU 并行带来更好的性能
用来控制多线下控制读写共享，访问一致性；避免竞争条件（race condition）

## 什么时候使用锁

如果两个及以上进程访问了一个共享的数据结构，并且其中一个进程会更新共享的数据结构，那么就需要对于这个共享的数据结构加锁。

## 锁带有哪些问题

锁本身会带来性能开销，使临界区的代码变成串行，限制了多核能力

多锁的也让情况变得复杂，例如死锁

锁确保了并发正确性，但是同时又会降低性能，这是个令人失望的现实，我们是因为并发运行代码才需要使用锁，而锁另一方面又限制了代码的并发运行。

还会带来编写程序的复杂性

## 单个锁发生死锁

1. 获取一把锁，进入临界区
2. 在临界区内又获取了一次这把锁
3. 简单说就是重复获取同一把锁，第一次成了，第二次必然死锁

显然第二次无法获取，他就一直阻塞下去了；这也叫做锁之间的 race

## 多锁

两个 CPU 不同的代码分支，并进入各自临界区，正好互相都需要对方锁住的资源，这里发生互相等待的锁释放，此时出现死锁；deadly embrace

例如一个程序不同线程上操作的`src`和`target`正好相反

如何解决呢，多个锁，需要对锁进行排序，所有的操作都必须以相同的顺序获取锁，这通常是复杂，很可能会破坏程序模块化。

## 拆锁

我们想要获得更好的性能，那么我们需要有更多的锁，拆大锁，但是这又引入了大量的工作。通常来说，开发的流程是：

1. 先以 coarse-grained lock（大锁）开始。
2. 再对程序进行测试，来看一下程序是否能使用多核。
3. 如果可以的话，那么工作就结束了，对于锁的设计足够好了；如果不可以的话，那意味着锁存在竞争，多个进程会尝试获取同一个锁，因此它们将会序列化的执行，性能也上不去，之后就需要重构程序。
4. 如果重新设计了加锁的规则，需要确保不破坏内核一直尝试维护的数据不变性
5. 所以如果不是必要的话，还是不要进行重构。

## 关闭中断

一些操作系统，通常它们都无锁的 acquire，因为它们假定自己都运行在单个处理器上，它们通过开关中断的操作来确保不会发生锁竞争

# really world 避免直接使用锁

很多现代语言都提供了内置稳定的同步机制

使用锁进行编程具有挑战性。通常最好是将锁隐藏在更高级别的构造中，比如同步队列
