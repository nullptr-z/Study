Concurrency

## 临界区

Critical Section，在并发程序的执行环境中，一段代码片段会访问公共资源(变量、设备、内存、文件..)，这一段代码就是**临界区**；
显然并发环境下需要加以限制，不然肯定会出问题

加锁后这段代码在多核下也是串行的, 也可以理解成这整段代码具有了原子性，因为对于其他线程来说，这段代码一旦进入肯定会从都执行到结束，即便被 CPU 打断，下次回来时 Content 甚至共享内存都不会发生变化

## 颗粒度

指的是临界区代码段的长度，颗粒度过大会影响性能，通常建议把不必要的代码放在锁外面，将大的临界区拆分成多个小的临界区(多锁)

## 原子交换指令

compare and swap

C 函数: `__sync_lock_test_and_set(a, b)`

## 锁

分为：可睡眠、不可睡眠

被锁在外面的进程(阻塞)，也会参数任务调度，这实际上是一种浪费，获得了 CPU 时间，却做不了任何事情

## 死锁

出现死锁的原因很多：

- 例如多锁之间互相等待
- 持有锁的进程 crash 了
- 在临界区代码包含了 return

> 解决方法：

- 保持锁的获取顺序一致，上锁和释放顺序应该相反
- 一个进程只允许持有一把锁，防止持有多把锁
- 原子性的一次性获取所有锁，一次性全部释放；缺点影响效率，就像是上了一把颗粒度很大的锁
- 少用锁，减少并发，优先功能实现，而且不是极致性能
- 单核处理器的黑魔法：直接关掉中断，防止任务调度

## 进程状态

操作系统可以通过维护进程控制块（Process Control Block，PCB）等数据结构，记录和管理每个进程的状态信息，以及与其相关的事件。这样，它可以及时了解一个进程是否被阻塞，并在必要时采取相应的调度和处理措施。

运行态（Running）： 进程目前正在执行指令。
就绪态（Ready）： 进程已经准备好执行，但尚未分配到 CPU 时间。
阻塞态（Blocked）： 进程因为等待某个事件（如 I/O 操作完成）而暂时无法执行。
创建态（New）： 进程正在被创建。
终止态（Terminated）： 进程已经执行完成或被终止。

================================
一些锁的实现

## 自旋锁

无限循环不停地获取锁，获取到了就上锁，防止其他进程获取, 主要要使用原子交换指令，判断状态和上锁一步完成

缺点：

1. 不建议在大颗粒度临界区代码使用自旋锁，因为其他进程也会参与任务调度，任务却得不到执行，浪费 CPU 时间
2. 在自旋锁临界区的任务进程不能主动放弃 CPU，因为会他不能放弃锁，解锁代码显然是最后执行的

![Alt text](image.png)

## 互斥锁

通常由操作系统支持，涉及到任务调度

根自旋锁的实现相似，不过他不会自旋，而是在获取锁失败时，进入睡眠

缺点：睡眠进程需要保存上下文，有一些性能开销；小颗粒度场景还是可以选择自旋锁的

## 信号量

通常由操作系统支持，涉及到任务调度

当任务请求信号量无法获得时，就会让任务睡眠(不再任务调度)进入等待列队，当信号量被释放时，列头的任务被唤醒执行

缺点：睡眠进程需要保存上下文

## 异步任务并发

特别适用于 I/O 密集型的应用，其中任务在等待外部资源时不会阻塞整个程序的执行。异步非阻塞任务通常使用异步编程模型和事件驱动的方法来实现。
