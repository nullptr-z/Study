## 文件即路由
自动根据目录结构创建对应层级结构的路由

## 代码拆分和预加载
自动代码拆分，只加载当前页面需要的代码

某个页面报错，不会影响其他页面

会对<Link/>指向的界面预加载（生产环境）

## 静态资源
直接通过"/log.png"直接可以引用，项目根目录"public"文件加中静态资源文件

## Head
`import Head from 'next/head'`
允许替代html标准的`<head>`

### css
CSS 模块，CSS 文件名必须以.module.css

/pages/_app.js中引入的CSS会影响全局CSS



# 预渲染
支持CDN命中

## 静态生成static
`build`编译构建代码时生成html

## 服务端生成request
`request`每当接收到请求时，在服务端渲染好HTML

> 可选择的预渲染SSR
静态的优势是`build`时渲染好，之后就可以一直使用'static，但是回来带一些问题，有些界面需要根据请求内容做出调整，应该在收到`request`渲染更为合适

注意build和request都是在服务端运行的，所以他们都属于SSR行为

## getStaticProps
[详细文档](https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticprops-static-generation)
```js
export async function getStaticProps() {
  return { props:{ ... } }
}
```
这个函数可以在构建阶段完成数据加载，传给当前页面的`default`组件

> *开发与生产
开发：在开发（npm run dev或yarn dev）中，getStaticProps每个请求时运行

生产：在生产中，getStaticProps在构建时运行'static。

这两点很重要,有些预渲染并不适合在用户请求之前执行，或者说不应该构建时渲染

## getServerSideProps
```js
export async function getServerProps(context) {
  console.log("context", context);
  return { props:{ ... } }
}
```
请求时被调用，context包含了请求时参数

仅在需要预渲染时才被调用，正常情况下无法不CDN缓存

# 客户端渲染



## SEO
搜索引擎优化，服务端渲染界面
