## Printf

%#v: 表示用和 Go 语言类似的语法打印值。对于结构体类型 来说，将包含每个成员的名字

## 变量的生命周期

go 语言中一个函数中局部变量,并不是一定分配在栈上的,也就是说可能不会随着作用域结束被释放

- 从一个函数中范围一个局部变量的地址
- 把一个局部变量的地址赋值给一个全局的或者说更高层级的指针

## switch

可以没有操作对象,被叫做无 tga switch, 等价于 switch true

多层循环情况 break 和 continue 可以直接退出到 label 标记的位置,使用场景较少

零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在**Go 语言中不存在未初始化的变量**

## new

在 go 里面 new 是一个预定义的函数,类似语法糖作用,没有新的基础概念
return new(int) 和 return &v
他们是一样的返回一个变量的地址

## 常量声明

未显示赋值的常量会复制前面常量值,类似不会增长的枚举声明
const (
a = 1
b
c = 2
d
)
fmt.Println(a, b, c, d) // "1 1 2 2"

#### iota

const (
Sunday uint = iota
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
)

Sunday 等于 0,之后元素每个自增 1,其他语言中的枚举类似

带表达式的 iota
const (
a uint = 1 << iota
b
c
d
)
fmt.Println(a, b, c, d) // "1,2,4,8"
随着 iota 自增每左移一位都是乘以 2

## 数组

golang 中的数组有类型的概念,**当一个数组的类型和长度相同时,他们类型则相同**
类型相同的数组可以进行 == != 比较,对每个元素进行逐一比较

## Slice --切片

Slice 并不能像数组一样进行 == != 比较; 有一个例外是可以和 nil 作比较
标准库仅提供用于 []byte 字节类型的 Slice 比较函数: bytes.Equal,按字节比较;对于其他类型则需要进行遍历进行比较

#### reverse

将指定范围 Slice 元素的位置反转.
a := [...]int{0, 1, 2, 3, 4, 5}
reverse(a[:])
fmt.Println(a) // "[5 4 3 2 1 0]"

#### append

append(slice, item| item..., item1, itemN)函数用于向 slice 追加一个或元素
后缀... 解构一个 Slice

#### copy

copy(x, y) 将 Slie 的所有元素赋值到 x; 返回成功赋值的元素个数

## 结构

两个中两个成员定义的顺序不同将是两个不同的结构--_好像没什么意义_

成员名字大写开头则代表,该成员是导出的

成员不能是自身结构类型,但是可以是指向自身类型的指针,例如链表和树

#### 比较

如果结构中所有成员都是可比较的,那么就可以使用 == 、!= 进行比较;
可比较的结构还可以用作 map 的 key

#### 匿名成员

type A struct { a int } `json:"color,omitempty"`
type B struct { A b int }
type C struct { B }
其中 C 包含了 A、B 所有成员
包含匿名成员的时必须显示对指定匿名成员的赋值

## json

将 Slice 转换位 json 的过程叫编组
将 Slice 转换位 json 格式:
紧凑型:json.Marshal(_Slice_)
带格式化型:json.MarshalIndent(_Slice_, "", " ");两个额外的字符串参数用于表示每一行输出 的前缀和每一个层级的缩进

#### 格式转换说明

例:`json:"color,omitempty"`
json: 代表 encoding/json 包的编码和解码的行为
"": 双引号第一个参数用于指定转换后的 key 值
omitempty: 当改成员为空或零值是转换时抛弃该成员

反转:
将 json 转换为 Slice: json.Unmarshal(data, &gobej)
gobej 为一个 Slice,转换后只会包含 gobej 对象存在的成员对象

基于流式的解码器 json.Decoder，它可以从一个输入流解码 JSON 数据，但这不是必须的
还有一个针对输出流的 json.Encoder 编码对象

template.HTML 该类型在生成 HTML 时可以保留标签的样式

## 函数

有时候会遇到没有函数体的的函数声明,那说明它不是用 go 实现的,可能是汇编语言(assembly)

#### 形参

没有默认参数,也没有命名参数
传参方式为值传递,传递的实参副本,不会改变实参原值;
注意:引用类型传递的也是改类型的副本,例如指针作为实参,就是拷贝一个新的指针,不过他们指向相同的地址
引用类型 指针、slice、map、function、channel 等类型

#### 标识符

函数的类型也叫标识符,两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为是相同的类型,与形参名函数名无关

## GC

GC 自动回收不再使用的内存,但是不会释放操作系统层面的资源:
比如打开的文件、网络连接。因此我们必须显式的释放 这些资源。
