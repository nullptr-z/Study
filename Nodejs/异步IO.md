## 磁盘 I/O

磁盘和内存之间的数据传递，CPU 发指令通知硬盘控制器去读，接下来等待硬盘控制器读取完成就可以了，读取这个期间不需要 CPU 参与的
也就是说磁盘 IO 是非阻塞式的,从硬盘读数据到内存这段时间，CPU 运算可以**并行**。

## 操作系统内核的 I/O 操作

_注意这里的非/阻塞是硬件层面的 和 软件层面的同步/异步 是没关联的_

- 阻塞式 I/O 是指：应用程序需要等待操作系统内核将 I/O 操作结果返回才能继续执行
- 非阻塞式 I/O 是指：应用程序通知操作系统内核发起 I/O 操作后，不需要等待 I/O 操作结果，可以直接后续代码执行，但是需要 I/O 操作结果时，需要不断轮询 I/O 操作结果。

## 同步/异步 IO

- 同步 I/O，程序运行和 I/O 操作跟踪只使用一个线程，导致 I/O 操作会阻塞程序运行。
- 异步 I/O，程序运行和 I/O 操作跟踪使用两个线程，这样程序运行就避免了被 I/O 操作阻塞

异步 I/O 并不一定是基于非阻塞式 I/O 的。

Node.js 服务器，是基于异步 I/O 设计的，它应答客户端请求的线程只有一个，且就是支持程序运行的线程，即 JS 主线程。

但是 Node.js 却不会因为 I/O 操作，发生客户端请求阻塞，因为 Node.js 采用了异步 I/O。

> 一句话概括就是主线程执行流程代码，遇到异步任务，就将任务交给异步线程，主线程继续执行后续代码，当主线程执行完毕后，就会进行事件循环，不断取出异步任务队列的结果和回调函数； PS 异步任务列队分为宏任务微任务。

Node.js 实现异步 I/O 是基于底层 libuv 库，在 libuv 库中有一个线程池，其中的线程用于处理异步任务。

即当 Node.js 主线程执行 JS 代码过程中，遇到异步任务，如 I/O 操作，就会将该异步任务交给 libuv 线程池处理。JS 主线程继续后续代码执行。

如果操作系统层面，I/O 模型是阻塞式的，则线程池线程会等待 I/O 操作结果，例如键鼠 I/O，网络请求

如果操作系统层面，I/O 模型是非阻塞的，则线程池会不断轮询 I/O 操作结果，例如磁盘 I/O

当线程池线程获得 I/O 操作结果后，会将结果和回调函数一起加入异步任务队列。

当 JS 主线程将程序代码执行完毕后，就会进行事件循环，不断取出任务队列的结果和回调函数，并执行。

[参考](https://blog.csdn.net/qfc_128220/article/details/122326661)
