## 引擎

三种引擎: innoDB 聚簇索引/myisam 非聚簇索引/memory
聚簇索引: 索引和数据放在一个文件

mysql 默认底层数据结构为 B+Tree, 现在主流的 innoDB 引擎只支持 B+Tree。

有些引擎还支持 Hashmap

innoDB 在内存充足的情况下比 myisam 快很多，因为它是把数据从磁盘加载到内存来查找数据的，myisam 和适合内存有限的场景

## 预读

innodb 每次读取 16KB 数据

## 提高 IO 效率

1. 减少次数
2. 减少数据访问量，保证业务数据完整前提下,减少查询的字段，缩短范围

## 索引存在哪里

存在磁盘里，查询数据的时候会优先加载索引到内存中

## 为什么使用 B+树

B+树数据是只存在叶子节点，叶子节点之间是相互连接的(双向链表)，可以线性的访问；mysql B+ Degree 被设置为 3 层

Hash: hash 桶过大，对内存要求高
BST: 有退化成链表风险
平衡树 AVL: 插入效率可能很低，需要保持平衡
红黑树: 深度越来越深，效率变低
B 数: 子节点存储数据有点浪费空间，如果查找的不是需要的数据，也被加载到了内存中

以上这些数据结构不可取原因在于，数据库通常是数据量非常庞大的，数据类型复杂，无法预测到底用哪种更合适
每种数据结构都用自己擅长的领域，但是都需要大都需要基于存放的数据类型提前确定使用哪种
B+适应面对未知复杂的数据适应能力最强

## 联合索引

多个字段组合共同索引

最左匹配: 使用联合索引时，是按照固定优先顺序匹配的；想象一下省>市>区选择的过程

`SELECT * FROM orders WHERE customer_id = ? AND order_date = ?`
为这种查询创建一个联合索引 INDEX(customer_id, order_date)将会提高查询性能，因为索引允许数据库直接定位到满足 customer_id 和 order_date 条件的行。

## 索引优化

- 使用 int 还是 varchar，取决于谁更小
- 高写入的场景可以先关掉添加索引，之后再统一为这些数据添加索引

取决于 B+树特性，key 占用字节越少越好，越少就能存储更多索引。也就是说选用占字节最少得字段做索引最优

自增主键有利于提高 B+树新增数据效率，因为不需要插入到已有数据中间，就不需要移动数据节点

Innodb 索引列选择优先级: 主键列 > 唯一列 > Row number

[参考](https://www.bilibili.com/video/BV1eq4y167Mv?p=32&spm_id_from=pageDriver&vd_source=29954a52608497ee1a304ca105f8cb17)
