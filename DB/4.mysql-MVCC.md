多版本并发控制 Multiply Version Concurrent Control

一种无锁并发控制机制，因为锁对性能影响较大，所以通过 MVCC 减少锁的使用；

- 版本控制：通过为数据的每次修改创建新的版本，同时保留旧版本，来支持并发访问。
- Undo Log：记录数据的旧版本，支持数据的回滚操作，并为 MVCC 提供必要的数据版本。
- Read View：确定事务可以看到哪些数据版本，保证了读取操作的一致性。

## 1.隐藏字段

数据库表中，除了我们定义的字段，还包含：

- DB_RTX_ID: 最近执行了创建、修改的那个事务的 ID
- DB_ROLL_PTR：回滚指针，指向这条数据的上一个版本，在 undolog 中
- DB_ROW_ID：数据行号，也叫隐藏主键，6 字节

## 2.回滚日志 undolog

保留了多条历史日志的链

多条事务，对一条数据记录做修改时，会形成一条线性旧数据的日志链，链首就是最新的记录，链尾是最早的记录

## 3.读视图 Read View

事务在进行`快照读`时产生的视图信息

- trx_list: 当前系统中活跃的事务 ID
- up_list_id: 列表中最小的 事务 ID
- low_limit_id: 系统尚未分配的下一个事务 ID

事务启动时创建：在 MVCC 中，当一个事务开始时（特别是在可重复读和读已提交隔离级别下），InnoDB 会为该事务创建一个读视图。读视图包含了在这个事务启动时刻，数据库中所有活跃事务的信息。

确定可见性：读视图中记录了在事务启动时刻，哪些事务已经提交，哪些事务还在进行中。这些信息用于判断当前事务读取数据时，哪些数据版本是可见的。简单来说，只有在当前事务启动前已经提交的数据修改，对当前事务是可见的；而在当前事务启动时或之后启动的其他事务所做的修改，对当前事务是不可见的。

提供一致性读：读视图的存在使得事务在整个执行过程中都能看到一致的数据快照，即使数据在事务执行期间被其他事务修改。这样的一致性读操作保证了数据的隔离级别，避免了不可重复读和幻读问题。

## 理解 MVCC

并发类型：

- 读读: 无数据安全问题
- 读写: 造成脏读、幻读、不可重复读
- 写写: 更新丢失，复写

- 当前读，读取的最新数据
- 快照读，读取的是历史版本数据

## 隔离级别-可见性

RR: 可重复读，默认; 一个事务在整个过程中可以多次读取同一数据并得到相同的结果

RC：读取已提交，保证一个事务不会读到其他事务未提交的数据，避免了脏读，但仍然可能遇到不可重复读（同一事务中两次读取同一数据集合得到不同结果）和幻读（在事务读取过程中，另一个事务插入了新的记录）的问题

串行化（Serializable: 最高隔离级别；这通常是通过对读取的每一行数据加锁实现的，完全隔离，但是可能会大幅度降低数据库的并发性能

## Purge 线程

MySQL 的 Purge 线程主要负责清理已经不再需要的 undolog 日志，这是为了释放存储空间并保持系统性能。 如果一直不清理链条会很长，占用空间，影响性能
在 InnoDB 存储引擎中，当事务被提交后，相关的 undolog 日志就不再需要了，但这些日志并不会立即被删除，而是通过 Purge 线程异步清理

[参考](https://www.bilibili.com/video/BV1EM4y1c7nk?p=11&vd_source=29954a52608497ee1a304ca105f8cb17)
