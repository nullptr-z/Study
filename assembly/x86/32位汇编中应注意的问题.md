分行书写代码用 \

将段名：name 修改为\_name@n(n 为局部变量字节数向上取 4 的倍数——32 位)

1、如果定义了 .model flat 内存模式，则 MASM 自动为各段寄存器做了如下定义：
assume cs:FLAT, ds:FLAT, ss:FLAT, es:FLAT, fs:error, gs:error
既 cs, ds, es, ss 段全使用平坦模式， fs, gs 默认不使用，这时若在程序中使用
fs, gs 编译器会报错。若要使用它们则应声明 assume fs:nothing, gs:nothing
或者 assume fs:flat, gs:flat
另外，在 .model 后还指定函数调用方式。因为 windows 中 API 调用使用的是 stdcall，所以
win32 汇编中只能使用 stdcall, 同时因为 win32 API 名称是区分大小写的，所以用
option casemap:none 指定程序对大小写敏感。

2、win32 环境中，每个程序在分开的虚拟地址空间中运行，每个应用程序拥有相互独立的 4GB 地址
空间，只有一种内存模式，即 flat 模式，整个 4GB 空间用一个 32 位地址就可以覆盖完。所以不再存在
DOS 汇编中的 segment 的概念。win32 汇编中的段指的是内存的“分类”。win32 中内存管理使用分页机制。
每个页（4KB）可自由指定属性，上一个 4KB 可能是代码，属性是可执行但不可写，下一个 4KB 就可能是
数据，属性是可读，可写，不可执行。win32 汇编中的段指的是把不同类型的数据或代码归类，再放到
不同属性的内存页。因此，虽然使用 DOS 汇编中同样的 .code .data 语句，但意义已经完全不一样。
.data 段 ：已初始化数据。属性可读可写。放在 EXE 文件中的\_DATA section 中。
.data? 段 ：未初始化数据。属性可读可写。在可执行文件中不占空间。放在\_BSS section 中。
注意，初始值用 ? 代替的变量可放在 .data 中，也可放在 .data? 中。
但放在 .data? 中不会增加 EXE 文件的大小。比如有定义
szBuffer db 100\*1024 dup(?) 如果程序的其他部分大小为 50KB。
那么将 szBuffer 放在 .data 中， exe 文件大小为 150KB；若放在 .data? 中
exe 文件的大小将仍为 50KB。
.const 段：常量。属性可读不可写。
以上三个段均为数据段，不可执行。

.code 段：指令。存放在\_TEXT section 中。属性可读可执行，在 ring3 中代码段不可写。
不过，代码段的属性由 PE 头部中的属性位决定，可编辑 EXE 文件，把代码段属性位
改成可写。那么在程序中就可以修改代码段。比如 UPX、PECompact 等软件就是
依靠把代码段进行变换来达到解压或解密的目的。
.stack 段：程序中不必定义堆栈段，系统自动分配。值得注意的是堆栈段的内存属性是
可读、可写并且可执行。这样靠动态修改代码的反跟踪模块可以拷贝到堆栈中
去边修改边执行。一些缓冲区溢出技术也用到了这个特征。
