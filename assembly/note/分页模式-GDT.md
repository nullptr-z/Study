## 不考虑兼容性的情况下
假设下，如果不考虑向下兼容，则首先需要32位的地址总线，并且需要一个可以进行寻址的32位段寄存，并且由于寄存器和地址总线的位数相同，完全可以直接用寄存器的值进行寻址，而不需要使用段模式寻址。但是，这样会导致之前所有的程序都无法使用，因为过去原有的程序的寻址方式都发生了改变。并且由于32位寄存器可以访问32位的所有地址（也就意味着进程可以访问任意的物理地址），所以只要能控制该寄存器就可以访问任意的地址，也就对内存没有保护的作用。

## 全局描述符表(GDT)的产生
`G1: 页表目录`​
`G2: 页表`​

为了能够保证向下兼容并且能够`@1对内存进行保护`和`划分段`，全局描述符表就产生了。

​我们知道在实模式下只能访问1MB的内存，并且使用的段寄存器+偏移地址的方式进行寻址，并且这种访存方式是不存在限制的。
为了能够对内存的操作加以限制（也就对内存进行保护），首先想到的方式就是通过查询一个`中间表`G1，表G1存储了每个地址段的访问权限，例如程序A想要访问0x0F000的内存，则可以先查询表G1，查看该内存地址是否可以让程序A进行访问。通过这种方式就可以对内存进行保护，这样就解决了内存保护的问题@1。

​现在则需要在向下兼容的基础上访问更大的地址空间，由于向下兼容的缘故，所以段寄存器使用的是16位的，那么如何使用16位的段寄存器去寻址32位的内存空间呢？@2 还是同样的方法，就是让段地址+偏移地址不在访问真实地址（这里指程序想要访问的物理地址），而是访问一个中间表G2，而G2则在内存中保存了想要访问的真实地址段，获取到真正的物理地址后由后续的32位寄存器进行访存操作就可以通过16位段寄存器完成4GB的内存访问。而将中间表G1和中间表G2合并就是全局描述符表(GDT)。而此时的段寄存器就不再是用于存储段地址了（此时段寄存器变为段选择子），而是用于存储访问GDT的下标，所以GDT的最大长度取决于段寄存器使用多少位来表示下标。

————————————————
原文：https://blog.csdn.net/l1004969690/article/details/113992196
