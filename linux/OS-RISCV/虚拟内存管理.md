## MMU

现代处理器大多都有一个叫内存管理单元(Memory Management Unit)的硬件，负责将虚拟地址转换成物

内存被分割成若干个页，内存管理单元维护了一个叫页表的东西

## Page 页

几乎所有处理器的`页`都规定为 4096(4kb)，页在物理内存中是连续的

## 虚拟地址 Virtual address

拿到虚拟地址在页表中找到页所在的物理地址

27 位索引:12 位偏移, 寻址能力为 512GB

偏移量：2^12 为 4kb,刚好一页大小

索引部分又被分为 3 级目录，每级目录大小为 2^9(512kb)；这么做是为了节省空间，因为大多时候并不需要那么大的虚拟地址页表(2^27)理地址
GPD->PD->PT，GPD 的 44 位(PPN)+12 位补 0,找到 PD，如此一层层,最终在 PT 找到物理地址

条目: 每个条目占 54 位，实际上只使用 44 位，保存的是 PPN,即物理地址索引

## PTE

0 位: Valid, 告诉 MMU 这个 PTE 是否有效
1 位: Read, 可读
2 位: Write, 可写
3 位: Executable, 允许执行
4 位: User, 用户权限下可以访问页面
...
9 位

## TLB 部件

页表缓存器，缓存最近使用的 PTE

刷新 TLB 指令为: sfence_vma, 页表切换时操作系统有义务维护 TLB, 防止 MMU 使用了过时的 TLB

## 物理地址 Physical address

寻址能力为 2^56, 实际上很多开发板没有支持这么大的寻址能力
44 位索引:12 位偏移

ps: 物理内存大于虚拟内存，虚拟内存耗尽(页表满)，但是物理内存中是还有可用空间的

ps2: 64 位只开放 56 位，可能是设计师认为更省电吧！实际上 56 位的寻址能力已经足以满足我们所有应用了

## Satp 寄存器

指向页的索引

## PCB

Page Control
