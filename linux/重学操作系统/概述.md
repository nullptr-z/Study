早期内存中有一种，类似小丑扔球的方式；不挺的刷新电容保持数据

Shell 是一个“把用户指令翻译成系统调用”的编程语言

## 操作系统做核心的工作

- 系统调用：提供特权级别的 API；每隔一段时间，操作系统负责强制中断一个进程切换到其他进程
- 进程任务调度：保存进程执行现场的状态，寄存器、内存。然后回复另一个进程状态;TSS、EFLANGS、TCB
- 资源分配：对硬件资源的管理，分配、回收、授权。。

#### QA: 如果没有操作系统会怎么样

- 也许一个进程会一直霸占 CPU，其他程序无法得到运行；
- 进程失去隔离性，对内存任意写入访问，破坏其他进程
- 没有防御性，几乎无法的应对恶意程序

## 内核

- 宏内核：操作系统内核代码全部在特权级模式运行（riscv 监督者模式）；集成
- 微内核：操作系统内核代码在用户模式下运行；模块化

## 强隔离性&多任务

现代 CPU 基本支持用户模式、内核模式，以及虚拟内存，以支持在 CPU 上运行`多任务`

> 内核模式

特权级指令，页表寄存器、状态寄存器、TSS、EFLANGS、TCB

> 用户模式

只能运行非特权级指令，如果尝试运行特权级指令，会让操作系统获得控制权，系统可以结束掉异常程序;

用户只能通过系统调用(syscall)执行特权指令，实际上用户不需要使用特权指令，只需要内核 API 的某个功能

> 虚拟内存

page table 页表：将虚拟地址映射到物理地址

每个进程都有属于自己的页表，可以访问任何位置，对于进程来说，页表就是他的全世界
提供了强大的内存隔离性
