## 反码:

原码+反码=最大数
8 为二进制中正数 1: 0000 0001 + 反码 1111 1110 =255
8 为二进制中负数-1: 1111 1111 + 反码 0000 0000 = -127

## 补码:

正数的补码:全部位取反+1
负数的补码:符号位不动其他位取反+1
原码+补码=0

这样的计算方式结果就是一个正数和他的相反数补码相同
一个负数的补码,去掉符号位,就是他的绝对值

8 位二进制的表示范围为:-127~127
8 位二进制补码中表示范围为:-128~127 -128 没有原码和反码,补码为 1000 0000:

## 异或

XOR，等同为 0，0:1 为 1；还可以理解为无进位相加

## 取反(非)

实际上 XOR,-1 等同于取反

## 算数移位

向右移动时，如果是一个负数，是带符号(1)的填充的

没有算数左移，因为会符号位会被移出去，破坏符号位

## 原理

2:10 公式->2^n 10001 位 4=位 0~位 3 的和; 二进制的 1 位最大表示 2 个数 0:1,也就相当与 2^4; (1*2^4)+(1*2^0)

2:16 公式->2^n （4 位一取,取值后拼接） 4 位二进制都为 1 的情况刚好等于一个最大的十六进制数 F

10:2 除 2
10:16 除 16

10:16 公式->16^n 相加
16:2 每位除 2

8:16 公式->20^n 相加
8 转 16 进制 倍率 8 4 2 1 循环

## 判断奇偶：

只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。因此可以用 if (a & 1)代替 if (a % 2)来判断 a 是不是偶数。——C#版（(a&1)==1）

## 两数交换：

——异或相等为 0，不等为 1
if (a != b)
{
a ^= b;
b ^= a;
a ^= b;
}

## 相反数：

取反+1；a=~a+1

## 绝对值：

对-1 异或相当于取反

解释：如果是负数右移取符号位会得到-1，对 int(有符号类型)的负数右移会使用 1 补位(算术右移)，所以等于-1，对于有符号数^-1 相当于取反
symbolByt = a >> (sizeof(int)\*8-1);
a = (a ^ bytSize)-symbolByt;

## 大小写转换:

大写 A 为 41H,小写 a 为 61H,他们差距为 20H,可行进行大于小于判断进行+,-;位操作能更效率

只需要对位 5 进行&

```sh
A 01000001
a 01100001
```

转换为大写，and 11011111(20H 反码), = 61h + DF = 41H,上溢过后的值(减去一个数 = 加上他的反码)

转换为小写, and 0100000(20H)
