互斥的原理就是将，并行的流转换成串行流

## Peterson 算法

无锁算法，基于共享内存，这里是指不依靠硬件指令

_它通常不用于现实世界的场景。现代编程语言和操作系统通常提供了用于管理并发的内置机制，如锁和信号量，原子指令_

Peterson 算法通常用于教育目的，以说明互斥的基本原理。

该算法通常用于两个进程的情况。以下是 Peterson 算法的基本工作原理：

初始化：

两个共享变量：int turn; 和 int flag[2];
turn 表示进入关键段的轮到哪个进程（0 或 1）。
flag[2] 是一个数组，每个进程有一个标志，初始化为 false。
进入关键段：

进入关键段之前，进程将其标志设置为 true（flag[i] = true;）。
然后将 turn 设置为另一个进程（turn = 1 - i;）。
进程检查另一个进程是否在其关键段中，以及是否轮到另一个进程。如果两个条件都成立，它会等待。
退出关键段：

离开关键段之前，进程将其标志设置为 false（flag[i] = false;）。
关键思想是，一个进程只有在轮到它并且另一个进程没有试图进入关键段时才能进入关键段。如果存在冲突，不允许进入关键段的进程将等待。

需要注意的是，尽管 Peterson 算法清晰地说明了互斥的概念，但由于其局限性以及更高效的替代方案，如基于硬件的解决方案或高级软件算法，
