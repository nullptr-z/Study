## 信号量

S: 非负整型,P 和 V 操作下 S 一定不会为负值，这个特效被称作`信号量不变性`

P(S): 将 S 减去 1，如果 S 变成 0，线程将挂起；--原子性 --Proberen(测试)

V(S): 将 S 加上 1，如果 S 从 0 变成非 0； V 操作随机重启一个被挂起的线程；--原子性 --Verhogen(增加)

- _共享访问控制_：防止竞争访问
- _共享调度控制_：要访问资源，需要达成一定的条件，未达成时资源被加锁

## 临界区

一段互斥访问的代码段,任意两个线程如果同时进入,就会破坏程序执行的结果的正确性

- 编写代码少应该尽可能减少临界区代码执行时间

## 原子操作:

指一条就完成的的操作,不可能中断

二元互斥量(互斥锁):

1. 枷锁 P(s)
2. 解锁 V(s)
   s >= O 时，其值表示还有可用的资源数;
   s < O 时，其绝对值表示有多少个进程因申请该信号量表示的资源，得不到而进入阻塞态;

## 锁(Lock)

CAS(compare and swap): 是个代价比较高的操作,它对内存进行独占访问
SpinLock: 空转,等到某个临界区可用的一种锁

- 上锁:获得临界区的访问,其他线程被挂起

### 技巧

用 channel 来控制两个线程的执行顺序。
例如有 t1, t2 两个线程,仅 join t1 线程, t2 一定在 t1 之后执行

## 死锁

由 P/V 操作顺序不当造成，出现某个线程等待另一个线程根本不可能发生的 V 操作

## 核心函数

```c
#include <semaphore.h>

int sem_init (sem_t *sem, O, uasigned int value) ; // 初始化信号量 sem
int sem_wait (sem_t *s)； // P(s)
int sem_ post (sem_t *s); // V (s)

sem_t * sem_open(argv[1], O_CREAT | O_EXCL, S_IRWXU, 1); // ios 10以上 sem_init 无法使用，替代方案
```

`sem_init`将`sem`设置为 value 的值

## P/V 核心理念：

同一个一原子操作加锁，一个原子操作解锁，使它们之间的代码独占访问权限，一旦加锁必须被解锁后才能被其他线程访问

#### 信号两是常用场景可以用读者(R)、写者(W)两种角色来描述

R:W 他们不必是对称的，可以是 1:1、1:N、N：1、N:N、M:N

由此可以再抽象出几种跟高级的用法：

- 读者优先；当第一个读者进入，启用互斥，最后一个读者离开，关闭互斥
- 写者优先；同上

可能需要注意饥饿问题，优先方可能不断进入访问列队，使另一方一直在等待

#### 优化事项

_尽可能压缩多线程代码段_

- P/V 同步的开销不小，是否需要使用并发
- 是否可以用局部变量代替或减少对内存引用

## 线程不安全函数

1. 不保护共享变量的函数
2. 保持跨越多个调用状态的函数，例如`rand`函数，这类函数只能重写
3. 函数返回指向静态变量的指针
4. 函数中调用了线程不安全函数

#### 可重入函数

线程安全函数的真子集

![](./%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0.png)

##### 死锁区域

![死锁](%E6%AD%BB%E9%94%81.png)
