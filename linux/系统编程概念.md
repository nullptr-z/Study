### 基本概念
  * 系统调用会将CPU从用户态切换到内核态.以便访问受保护的内核内存
  * 系统调用是固定组成的,每个系统调用都由一个唯一的数字来表示.(编写程序是使用系统名称来进行系统调用,通常对这个系统调用编号一无所知)
  * 每个系统调用可以使用一套辅助参数,对传递的参数进行规范
  * 系统调用不会分配内存缓冲区(例如数组,字符串或其他形式的内存空间)给调用者
  系统调用和函数调用最大的区别就在于,系统调用开销很大; 需要切换到内核态(0特权级)这需要保存大量当前用户态的信息,为了切换回来时恢复现场

### 不同的C语言函数库
最常用的GUN C语言函数库glibc;
同样也有其他的领域嵌入式领域 受限内存条件下的C语言函数库,例如dietlibc uClibc
**查看glibc版本**
glib定义了两个常量,`_GLIBC_`和 `_GLIBC_MINOR_`,例如版本2.13 他们分别代表2和13
```c
#include <stdio.h>
#include <gnu/libc-version.h>
int main(){
	printf("%s\n",gnu_get_libc_version());
}
```
还有`confstr()`同样用于查看版本

### C语言进行系统调动过程--系统调用步骤.png
*系统命名通常采用sys_xxx形式*
  * 程序通过C语言函数库中的外壳函数发起系统调用
  * 系统调用中断例程要求所有的参数是可用的;如果内核希望这些参数传入寄存器,外壳就会将这些参数复制到寄存器
  * 所有系统调用进入内存的方式都是相同的,外壳函数将系统调用编号传入EAX寄存器,指定系统调用
  * 旧: 外壳函数执行**int 80h**中断指令,引发从用户态切换到核心态,并执行该中断的中断矢量所指向的代码
  * 新: 2.6内核及glibc 2.3.2以后都支持使用sysenter指令进入内核,速度更快
  * 为了响应80中断,内核调用**system_call()**例程来处理本次中断
    1) 在内核栈中保存当前寄存器值
    2) 检查系统调用编号的有效性
    3) 使用系统调用编号在**系统调用例程表(sys_call_table)**(编号1对应第1条,包含对应例程地址)中进行索引,找到对应的系统调用服务例程进行调用.如果该调用例程带有参数,那么将先检查参数的有效性,检查地址指向用户空间的内存位置是否有效;在内核内存和和用户内存之间传递数据;最后系调用例程将结果返回给system_call()例程
    4) 从内核栈中恢复各个寄存器值,并将系统调用返回值置于栈中
    5) 返回至外壳函数,同时将CPU切回用户u
  * 如果系统调用例程的返回值表明调用遇到错误,外壳函数会使用该值设置全局变量errno;然后外壳函数返回到调用程序并同时返回状态码
  *Linux上,系统调用惯例是调用成返回非负值,错误则对errno取反,返回这个负值;C语言外壳函数会对这个负值再次取反,并且复制到errno,然后使用-1作为外壳函数的返回值,以表示错误发生*

## 调用错误
### 养成好习惯,检查函数的返回状态
几乎每一个系统调用和库函数都会返回状态值,对每个调用的返回检查状态能节省调试代码的时间
有少数几个系统调用总是不会失败的,他们无需检查返回状态:
  * getpid()总能成功返回进程ID
  * _exit()总能成功终止进程

### 处理系统效用错误
系统调用失败时会将全局变errno设置为一个正值编号,以表示具体错误;
<errno.h>头文件对errno进行了声明,还有一组对各种错误进行定义的常量,这些常量都是字母E开头的--手册中ERRORS章节
进行系统调用因为错误情况总是返回-1表示错误,所以先判断函数调用返回的状态如果-1,再对errno的值进行判断才是有效的.
errno全局的,它的值有可能是之前其他函数调用的错误
少数系统调用成功时也返回-1,这就需要在调用前重置errno为0

  * perror(const *str msg) 输出msg,并紧跟errno值对应的错误消息
  * strerror(int errnnum) 输出errnnum对应错误号的字符串
  这两个调用都属于本地语言敏感的,就是会使用本地语言

### 标准系统数据类型
大多标准数据类型都在<sys/types.h>头文件中,命名都已_t结尾;
C99新增修饰符:
  1) %zd对size_t或ssize_t进行统一输出;%d %ld
  2) %jd对intmax_t,uintmax_t和int128_t这一类类型进行统一输出;%ld %lld
  但是都没有得到Unix的实现支持
