PS: 面向系统级编程时，其每一个系统调用，都能为程序功能带来大量的可扩展性

### 基本概念

- 系统调用会将 CPU 从用户态切换到内核态.以便访问受保护的内核内存
- 系统调用是固定组成的,每个系统调用都由一个唯一的数字来表示.(编写程序是使用系统名称来进行系统调用,通常对这个系统调用编号一无所知)
- 每个系统调用可以使用一套辅助参数,对传递的参数进行规范
- 系统调用不会分配内存缓冲区(例如数组,字符串或其他形式的内存空间)给调用者
  系统调用和函数调用最大的区别就在于,系统调用开销很大; 需要切换到内核态(0 特权级)这需要保存大量当前用户状态的信息,以便切换回来时恢复现场

### 不同的 C 语言函数库

最常用的 GUN C 语言函数库 glibc;
同样也有其他的领域嵌入式领域 受限内存条件下的 C 语言函数库,例如 dietlibc uClibc
**查看 glibc 版本**
glib 定义了两个常量,`_GLIBC_`和 `_GLIBC_MINOR_`,例如版本 2.13 他们分别代表 2 和 13

```c
#include <stdio.h>
#include <gnu/libc-version.h>
int main(){
	printf("%s\n",gnu_get_libc_version());
}
```

还有`confstr()`同样用于查看版本

### C 语言进行系统调动过程--系统调用步骤.png

_系统命名通常采用 sys_xxx 形式_

- 程序通过 C 语言函数库中的外壳函数发起系统调用
- 系统调用中断例程要求所有的参数是可用的;如果内核希望这些参数传入寄存器,外壳就会将这些参数复制到寄存器
- 所有系统调用进入内存的方式都是相同的,外壳函数将系统调用编号传入 EAX 寄存器,指定系统调用
- 旧: 外壳函数执行**int 80h**中断指令,引发从用户态切换到核心态,并执行该中断的中断矢量所指向的代码
- 新: 2.6 内核及 glibc 2.3.2 以后都支持使用 sysenter 指令进入内核,速度更快
- 为了响应 80 中断,内核调用**system_call()**例程来处理本次中断
  1. 在内核栈中保存当前寄存器值
  2. 检查系统调用编号的有效性
  3. 使用系统调用编号在**系统调用例程表(sys_call_table)**(编号 1 对应第 1 条,包含对应例程地址)中进行索引,找到对应的系统调用服务例程进行调用.如果该调用例程带有参数,那么将先检查参数的有效性,检查地址指向用户空间的内存位置是否有效;在内核内存和和用户内存之间传递数据;最后系调用例程将结果返回给 system_call()例程
  4. 从内核栈中恢复各个寄存器值,并将系统调用返回值置于栈中
  5. 返回至外壳函数,同时将 CPU 切回用户 u
- 如果系统调用例程的返回值表明调用遇到错误,外壳函数会使用该值设置全局变量 errno;然后外壳函数返回到调用程序并同时返回状态码
  _Linux 上,系统调用惯例是调用成返回非负值,错误则对 errno 取反,返回这个负值;C 语言外壳函数会对这个负值再次取反,并且复制到 errno,然后使用-1 作为外壳函数的返回值,以表示错误发生_

## 调用错误

### 养成好习惯,检查函数的返回状态

几乎每一个系统调用和库函数都会返回状态值,对每个调用的返回检查状态能节省调试代码的时间
有少数几个系统调用总是不会失败的,他们无需检查返回状态:

- getpid()总能成功返回进程 ID
- \_exit()总能成功终止进程

### 处理系统效用错误

系统调用失败时会将全局变 errno 设置为一个正值编号,以表示具体错误;
<errno.h>头文件对 errno 进行了声明,还有一组对各种错误进行定义的常量,这些常量都是字母 E 开头的--手册中 ERRORS 章节
进行系统调用因为错误情况总是返回-1 表示错误,所以先判断函数调用返回的状态如果-1,再对 errno 的值进行判断才是有效的.
errno 全局的,它的值有可能是之前其他函数调用的错误
少数系统调用成功时也返回-1,这就需要在调用前重置 errno 为 0

- perror(const \*str msg) 输出 msg,并紧跟 errno 值对应的错误消息
- strerror(int errnnum) 输出 errnnum 对应错误号的字符串
  这两个调用都属于本地语言敏感的,就是会使用本地语言

### 标准系统数据类型

大多标准数据类型都在<sys/types.h>头文件中,命名都已\_t 结尾;
C99 新增修饰符:

1. %zd 对 size_t 或 ssize_t 进行统一输出;%d %ld
2. %jd 对 intmax_t,uintmax_t 和 int128_t 这一类类型进行统一输出;%ld %lld
   但是都没有得到 Unix 的实现支持
