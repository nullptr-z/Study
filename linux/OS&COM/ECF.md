# 概览

异常控制流 ECF, Exceptional Control Flow

想象下一个按顺序执行的程序，需要它停下来接受输入、出现异常时进入异常处理、开启新的运行副本等，一条能跳出程序顺序执行流程的操作，他们是怎样做到的

- 对于操作系统，实现 IO、进程、虚拟内存，都依赖于 ECF 为基础
- 对于并发来说，异常处理、时间重叠上执行进程、信号都依赖 ECF
- 对于编程语言想要实现，try catch throw 都离不开 ECF，非本地跳转
- ...各个层次都存在不同形式的 ECF

## 异常

由操作系统和硬件配合实现

1. 异常表
2. 执行异常处理程序
3. 最后异常处理程序触发以下情况之一：

- 返回给 CS 指针，发生异常的那条指令，然后继续执行
- 返回，发生异常那条指令的下一条指令
- exit

## 异常号

硬件设计者分配的：

- 除数为 0
- 算数运算溢出
- 缺页
- 内存访问越界
- 断点

操作系统开发者分配的：

- 系统调用
- 外围设备 IO 信号

## 异常表

存放异常号(索引)和与其对应的异常处理程序

表地址,存放在 CPU 的一个寄存器中，`异常表基地址寄存器`(exceptional table base register)

## 异常处理程序

调用异常处理程序，和常规的例程调用类似

1. 入栈用于返回的地址，根据不同异常类型，保存当前或者下一指令地址
2. 当前例程的运行状态入栈，flags, ...

这里这些例程运行在内核模式下，所以使用的是`内核栈`，0 特权级，操作系统资源访问权限

## 硬中断

80: 应用程序发起系统调用
