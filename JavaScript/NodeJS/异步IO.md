## 磁盘I/O
磁盘和内存之间的数据传递，CPU发指令通知硬盘控制器去读，接下来等待硬盘控制器读取完成就可以了，读取这个期间不需要CPU参与的
也就是说磁盘IO是非阻塞式的,从硬盘读数据到内存这段时间，CPU运算可以**并行**。

## 操作系统内核的I/O操作
*注意这里的非/阻塞是硬件层面的 和 软件层面的同步/异步 是没关联的*
* 阻塞式I/O是指：应用程序需要等待操作系统内核将I/O操作结果返回才能继续执行
* 非阻塞式I/O是指：应用程序通知操作系统内核发起I/O操作后，不需要等待I/O操作结果，可以直接后续代码执行，但是需要I/O操作结果时，需要不断轮询I/O操作结果。

## 同步/异步IO
* 同步I/O，程序运行和I/O操作跟踪只使用一个线程，导致I/O操作会阻塞程序运行。
* 异步I/O，程序运行和I/O操作跟踪使用两个线程，这样程序运行就避免了被I/O操作阻塞

异步I/O 并不一定是基于非阻塞式I/O的。


Node.js服务器，是基于异步I/O设计的，它应答客户端请求的线程只有一个，且就是支持程序运行的线程，即JS主线程。

但是Node.js却不会因为I/O操作，发生客户端请求阻塞，因为Node.js采用了异步I/O。

Node.js实现异步I/O是基于底层libuv库，在libuv库中有一个线程池，其中的线程用于处理异步任务。

即当Node.js主线程执行JS代码过程中，遇到异步任务，如I/O操作，就会将该异步任务交给libuv线程池处理。JS主线程继续后续代码执行。

如果操作系统层面，I/O模型是阻塞式的，则线程池线程会等待I/O操作结果，例如键鼠I/O，网络请求

如果操作系统层面，I/O模型是非阻塞的，则线程池会不断轮询I/O操作结果，例如磁盘I/O

当线程池线程获得I/O操作结果后，会将结果和回调函数一起加入异步任务队列。

当JS主线程将程序代码执行完毕后，就会进行事件循环，不断取出任务队列的结果和回调函数，并执行。

[参考](https://blog.csdn.net/qfc_128220/article/details/122326661)
