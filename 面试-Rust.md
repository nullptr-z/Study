## Rust 如何保证并发安全的？

1. 一个可变变量默认就是互斥的，这与并发是用的锁异曲同工之处，一个变量只能有一个可变的引用，或者多个比可变引用，二者不能同时存在，者直接解决数据竞争问题；为了在多线程中安全地共享数据，Rust 提供了 Mutex 和 RwLock 等类型，它们使用互斥锁和读写锁来管理对数据的访问
2. 堆变量与函数调用栈(入参)生命周期绑定，函数作用域结束就销毁；几乎避免了悬垂指针出现的可能，也就是说他的所有可能得引用和数据本身都被释放了
3. 所有权 move 语义，默认赋值、传参就移动变量所有权，有助于避免数据竞争；如果不想移动那应该使用 clone 或者 Rc/Arc

## 如何返回函数内部创建变量？

1. 如果变量是 Copy 的，直接返回
2. 对于栈上的变量默认 Rust 是 move 的，直接返回即可转移所有权
3. std::mem::take 夺走变量的所有权，内部变量就变成了 default 的值了
4. 在堆上创建数据，如果担心开销，使用 Rc/Arc
