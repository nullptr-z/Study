A closure expression produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables.
闭包是一种匿名类型，一旦声明，就会产生一个新的类型，但这个类型无法被其它地方使用。这个类型就像一个结构体，会包含所有捕获的变量。


可以将rust闭包简单理解为编译后会存在于可执行文件代码段中的一个结构。结构中包含一个可以调用的函数，以及可能被需要的，从声明闭包的上下文中捕获的额外数据
就像是在代码段中的，子代码段，这时，如果*被捕获的变量是可变引用*，在这个闭包后续的代码中将不能再使用这个变量的引用；所有权规则：上下文中只能存在一个可变或者多个不可变引用


## FnOnce
闭包只能被使用一次
```rs
// Trait的定义
call_once(self, args)
```
第一个参数为self，也就是说一旦被调用，闭包本身的所有权就被move到闭包内部

## FnMut
捕获变量可变;继承了FnOnce
```rs
// Trait的定义
call_once(&mut self, args)
```
如果被捕获的变量是可变的，且在闭包中改变这个变量，需要将闭包也声明为可变的

## Fn
捕获变量不可变，继承了FnMut
```rs
// Trait的定义
call_once(&self, args)
```
