### Rust 内存管理设计思想

Rust 的创造者们，重新审视了堆内存的生命周期，发现**大部分堆内存的需求在于动态大小，小部分需求是更长的生命周期**。所以它默认将堆内存的生命周期和使用它的栈内存的生命周期绑在一起，并留了个小口子 leaked 机制，让堆内存在需要的时候，可以有超出帧存活期的生命周期。

## Box

`Box<T>` 一个智能指针,在堆内存上创建在数据结构,在栈上创建一个指向该结构的指针,生命周期和这个指针一致,编译时确定 size,{ ptr, len }
`Box::leak(Box::new(T))` 强制结构 T 创建在堆上;绕过静态检查,拥有静态生命周期

## RefCell

获得内部数据的可变/不可变借用，在运行时而不是在编译时执行 Rust 的借用规则。

它使用智能指针和运行时检查的组合来确保你遵循借用规则，防止数据竞争并确保内存安全

```rs
// 运行时会检查到所有权错误，不能同时存在可变引用和不可变引用
{
    let a = RefCell::new(1);
    let c = a.borrow_mut();
    let b = a.borrow();
}
// 正确使用方法，使用花括号缩短`c`的生命周期,保证了不会和后续的借用冲突，且不会引用已释放内存
{
    let a = RefCell::new(1);
    {
      let c = a.borrow_mut();
    }
    let b = a.borrow();
}
```

## Cow<'a, B>

用于提供写时克隆（Clone-on-Write）的一个智能指针;

包裹一个只读借用，但如果调用者需要所有权或者需要修改内容，那么它会 clone 借用的数据。

## Arc

引用技术，多线程中安全访问

```rs
/// 创建一个只读字符串切片
Arc::<str>::from("123")
/// 匹配两个指针指向同一个元素
Arc::ptr_eq(p, q)
```
