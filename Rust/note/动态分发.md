_看到 dyn 关键字就知道后面跟的是一个 trait 了。_

## Trait Object

这种用法叫做`动态分发`，推迟到运行时再赋予数据类型，表现为 `&dyn Trait `或者 `Box<dyn Trait>`两种形式

还可以用来解决，`静态分发`下泛型的单态化，造成的编译后二进制变大问题，当然非必要不使用，因为他有略微性能损耗

动态分发的核心思想就是，限定对象的调用域(字段、函数)，根据赋值的对象调用对应的域；当然这跟弱类型语言是两码事

## Trait Object 的底层逻辑就是胖指针`{ ptr, meta }`:

> ptr: 指向数据本身(原生类型数据，二进制)，实际上就是把赋值的对象看做**无类型**纯粹的二进制
> meta: 指向虚函数表，包含具体类型结构的信息，如 size、aligment 以及一系列成员函数指针等，根据这些信息的大小和对齐方式，对二进制数据结构化
> 实际普通的结构(struct)，在内存中也是如此，不过编译时就是已知成员变量、方法所在地址的

[Trait Object](./快速回忆/trait%20object.png)

## 有哪些限制

1. 如果 trait 所有的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能用于 trait object。不允许返回 Self，是因为 trait object 在产生时，原来的类型会被抹去，所以 Self 究竟是谁不知道。
2. 不允许携带泛型参数，是因为 Rust 里带泛型的类型在编译时会做单态化, 是`静态生成`，而 trait object 是运行时的产物，两者不可能同时存在。

## 其他语言中的动态分发

> 面向对象语言中 C++,java 叫做`运行时多态`，通过父类对象调用 Override 函数使用一个子类实现
> 像 JavaScript 不断在原型链向上查找函数方法的机制，也是`动态分发`
