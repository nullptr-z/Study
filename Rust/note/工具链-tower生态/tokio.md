## #[tokio::main]

将 `async fn main`转换为普通 `fn main`函数

```rust
fn main() {
    let mut rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        // 这里为 async fn main中的代码
        println!("hello");
    })
}
```

## Work stealing（工作窃取）

是一种动态负载平衡策略，用于多线程和并行计算环境。在这种策略中，空闲的线程（或处理器）会从繁忙的线程（或处理器）那里窃取工作，以实现计算任务之间的平衡分配。工作窃取策略在多核处理器系统中尤为重要，因为它能够更有效地利用处理器资源，提高并行计算的性能。

以下是工作窃取策略的一些关键特点：

自适应负载平衡：工作窃取能够在运行时根据系统负载动态地重新分配任务。这意味着，当某些线程变得空闲时，它们会主动寻找并处理其他线程尚未完成的任务。

非阻塞：工作窃取策略通常采用非阻塞算法，这意味着线程在尝试窃取工作时不会阻止其他线程的执行。这有助于提高并行计算的效率。

分布式任务队列：工作窃取策略通常使用分布式任务队列来存储待处理的任务。每个线程都有自己的任务队列，这样线程在处理任务时就可以避免竞争，提高性能。

适用于多种并行编程模型：工作窃取策略可以应用于多种并行编程模型，例如线程池、任务并行库、并行循环等。这使得工作窃取成为多核处理器系统中一种通用的负载平衡策略。

总之，工作窃取是一种高效的动态负载平衡策略，可以在多线程和并行计算环境中实现任务的平衡分配，从而提高整体性能。
