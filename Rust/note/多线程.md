并发：正在执行一项任务期间，可以中断开启其他任务
并行：同时执行不同的任务

消息传递（Message passing）并发：其中通道（channel）被用来在线程间传递消息。
共享状态（Shared state）并发：其中多个线程可以访问同一片数据。

竞争状态（Race conditions）：多个线程以不一致的顺序访问数据或资源，访问了临界区代码
死锁（Deadlocks）：两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行

## 线程模型

由于 Rust 是较为底层的语言，因此，Rust 标准库只提供了 [1:1](#线程创建) 线程模型实现，即 1 个语言线程对应 1 个系统线程。

绿色线程的 M:N 模型，即 M 语言线程 N 个系统线程，运行时把任务分配到不同的系统线程去执行。这种模型需要更大的语言运行时来管理这些线程。如果愿意牺牲性能来换取抽象，以获得对线程运行更精细的控制及更低的上下文切换成本；有第三方实现了 M:N 线程模型的 crate。

## 线程创建：

不同编程语言有一些不同的方法来实现线程。很多操作系统提供了创建新线程的 API。这种由编程
语言调用操作系统 API 创建线程的模型有时被称为 1:1，一个 OS 线程对应一个语言线程。
这种方式更为底层，控制更精细——Rust 标准库只实现了这种模式

很多编程语言提供了自己特殊的线程实现。编程语言提供的线程被称为 绿色（green）线程，
使用绿色线程的语言会在不同数量的 OS 线程的上下文中执行它们。为此，绿色线程模式被
称为 M:N 模型： M 个绿色线程对应 N 个 OS 线程，这里 M 和 N 不必相同。
——Rust 没有实现这种模式，需要第三方 Crate

## 通道

Rust 标准库的通道是多生产者，单消费者的（多个发送端，单个接收端；多个小溪汇聚成一个大河）

当发送者或接收者任一被丢弃时可以认为通道被 关闭（closed）了

### recv()

它是 receive 的缩写。这个方法会`阻塞主线程`执行直到从通道中接收一个值。

### try_recv()

它立刻返回一个 `Result<T, E>` ： Ok 值包含可用的信息，而 Err 值代表此时没有任何消息。可以编写一个循环来频繁调用 try_recv,在有可用消息时进行处理

## ps:

主线程执行完,子线程不管是否执行完成,都会离开所在函数,也就是说代码会往后执行
`spawn`函数返回` JoinHandle`,调用其`join()`方法阻塞当前线程直到调用者的线程执行结束

## 创建线程池 std::net::ThreadPool

new(n): n 线程数量

execute(): 有着类似 thread::spawn 的行为,它接受一个闭包,从线程池中找到空闲线程执行这个闭包

## Arc 智能指针：

以引用计数来保证所有权机制在多引用情况下运行正常

## Mutex 互斥锁：

它记录谁有数据的排他访问权。避免多线程中竞争条件，任意时刻，其只允许一个线程访问能某些数据。

## 并发

并发是一种能力，而并行是一种手段。当我们的系统拥有了并发的能力后，代码如果跑在多个 CPU core 上，就可以并行运行。所以我们平时都谈论高并发处理，而不会说高并行处理。
很多拥有高并发处理能力的编程语言，会在用户程序中嵌入一个 M:N 的调度器，把 M 个并发任务，合理地分配在 N 个 CPU core 上并行运行，让程序的吞吐量达到最大。

并发是对并行的实现/使用，是同时与多个任务打交道的能力；
并行是并发的体现，是同时处理多个任务的手段，表现形式为多个 CPU 同时工作。

## 同步和异步同步

是指一个任务开始执行后，后续的操作会阻塞，直到这个任务结束。在软件中，我们大部分的代码都是同步操作，比如 CPU，只有流水线中的前一条指令执行完成，才会执行下一条指令。一个函数 A 先后调用函数 B 和 C，也会执行完 B 之后才执行 C。

- 初始状态，Promise 还未运行；
- 等待（pending）状态，Promise 已运行，但还未结束；
- 结束状态， Promise 成功解析出一个值，或者执行失败。

如果你对 Promise 这个词不太熟悉，在很多支持异步的语言中，Promise 也叫 Future / Delay / Deferred 等。除了这个词以外，我们也经常看到 async/await 这对关键字。
一般而言，async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行。大多数语言中，async/await 是一个语法糖（syntactic sugar），它使用状态机将 Promise 包装起来，让异步调用的使用感觉和同步调用非常类似，也让代码更容易阅读。
同步阻塞后续操作，异步允许后续操作。被广泛用于异步操作的 Promise 代表未来某个时刻会得到的结果。

## 并发和异步

他们关系密切

异步关注如何避免阻塞线程

并发关注如何最大化地利用计算资源。
