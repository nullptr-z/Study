##　Rust 常量的命名规范
是使用下划线分隔的大写字母单词，并且可以在数字字面值中插入下划线来提升可读性
--常量被编译后字面值，所以必须在编译期间确认
```rs
const MAX_POINTS: u32 = 100_000;
```


##　mut 易变类型
易变的变量也无法改变这个变量的类型，类型变量初始化时确认
编译错误：
```rs
let mut a=1
a="2"
```

可以使用let重新声明这个变量
```rs
let mut a=1
let a="2"
```

##　数据类型

### 浮点
Rust
的浮点数类型是 f32 和 f64 ，分别占 32 位和 64 位。默认类型是 f64 ，因为在现代 CPU
中，它与 f32 速度几乎一样，不过精度更高

### 字母类型 char
Rust的 char类型是语言中最原生的 --字母类型
char 类型的大小为四个字节,代表了一个 Unicode标量值
-- 并非传统的１字节，ascii标量值

### 元组类型
元组长度固定：一旦声明，其长度不会增大或缩小
```rs
let tup: (i32, f64, u8) = (500, 6.4, 1);

let (x, y, z) = tup;

println!(" {} {} {}", x, y, z);
```

```rs
let x: (i32, f64, u8) = (500, 6.4, 1);

println!(" {} {} {}", x.0, x.1, x.2);
```

### 单元类型（unit type）：()
其实就是一个空元组(),他被视为非复合类型

### 数组
一整块连续的，在栈空间分配的内存
```rs
let a: [i32; 5] = [1, 2, 3, 4, 5]

/* 长度为５，每个元素都是３ */
let a = [3; 5];
```


## Rust是基于表达式的语言
```rs
{
    let x = 3;
    x + 1
}
```
是一个代码块，它的值是 4 。这个值作为 let 语句的一部分被绑定到 y 上。注意结尾没
有分号的那一行 x+1 ，与大部分代码行不同。表达式的结尾没有分号。如果在表达
式的结尾加上分号，它就变成了语句，而语句不会返回值。

在 Rust 中，函数的返回值等同于函数体最后一个表达式(没有；)的值。使用 return 关键字和指
定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。

使用空元组　() 表示不返回值

### 流程控制
```rs
let number = if condition {5} else {6};

loop {
    println!("无限循环!");
}

while condition {
    println!("条件循环", );
}
```


## 字符串Slice
--和数值类型一样，属于无所有权全类型；类型名str

猜测：字符串 slice 实际上就是一个指向字符串中一段连续内存的指针，以及这个内存段的长度` { *ptr, len }`；；而字符串字面值的类型就是 &str，表示指向编译时常量区域的字符串 slice。
```rs
struct Silce {
    *start: u32,
    *end: u32,
}
```

#### 字符串字面值就是 Slice
start、end指向程序代码段位置    --）

